<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="陈钟诚" />
  <title>人工智慧 - 採用 JavaScript 实作</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
    table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
    table.sourceCode { width: 100%; line-height: 100%; }
    td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
    td.sourceCode { padding-left: 5px; }
    code > span.kw { color: #007020; font-weight: bold; }
    code > span.dt { color: #902000; }
    code > span.dv { color: #40a070; }
    code > span.bn { color: #40a070; }
    code > span.fl { color: #40a070; }
    code > span.ch { color: #4070a0; }
    code > span.st { color: #4070a0; }
    code > span.co { color: #60a0b0; font-style: italic; }
    code > span.ot { color: #007020; }
    code > span.al { color: #ff0000; font-weight: bold; }
    code > span.fu { color: #06287e; }
    code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/book.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
  <h1><a href="book.html">人工智慧 - 採用 JavaScript 实作</a></h1>
  <table id="bar" border="0" style="border:0;"><tr style="border:0;">
    <td style="text-align:left;border:0;"> <a href="book.html">目录</a> | <a href="download.html">下载</a></td>
    <td style="text-align:right;border:0;"><a href="http://ccckmit.wikidot.com/">陈钟诚</a> 於 <a href="http://www.nqu.edu.tw/">金门大学</a></td>
  </tr></table>
</div>
<div id="content">
  <div id="header">
    <h1 class="title">人工智慧 - 採用 JavaScript 实作</h1>
    <h2 class="author">陈钟诚</h2>
    <h3 class="date">2014 年 8 月</h3>
  </div>
  <div id="TOC">
    <ul>
      <li><a href="#序">序</a></li>
      <li><a href="#授权声明">授权声明</a></li>
      <li><a href="#人工智慧简介">人工智慧简介</a><ul>
        <li><a href="#何谓人工智慧-ai">何谓人工智慧 (AI) ?</a></li>
        <li><a href="#ai-的方法">AI 的方法</a></li>
        <li><a href="#ai-的梦想">AI 的梦想</a></li>
      </ul></li>
      <li><a href="#爬山演算法">爬山演算法</a><ul>
        <li><a href="#实作以爬山演算法寻找函数最高点">实作：以爬山演算法寻找函数最高点</a></li>
        <li><a href="#实作通用的爬山演算法架构">实作：通用的爬山演算法架构</a></li>
        <li><a href="#实作通用的模拟退火法架构">实作：通用的「模拟退火法」架构</a></li>
      </ul></li>
      <li><a href="#神经网路简介">神经网路简介</a><ul>
        <li><a href="#实作单层感知器-perceptron">实作：单层感知器 (Perceptron)</a></li>
        <li><a href="#实作多层感知器与反传递演算法">实作：多层感知器与反传递演算法</a></li>
        <li><a href="#图形搜寻简介">图形搜寻简介</a></li>
        <li><a href="#实作深度与广度搜寻法">实作：深度与广度搜寻法</a></li>
        <li><a href="#实作以深度优先搜寻解决老鼠走迷宫问题">实作：以深度优先搜寻解决老鼠走迷宫问题</a></li>
        <li><a href="#实作以广度优先搜寻解决拼图问题">实作：以广度优先搜寻解决拼图问题</a></li>
      </ul></li>
      <li><a href="#电脑下棋">电脑下棋</a><ul>
        <li><a href="#实作五子棋程式">实作：五子棋程式</a></li>
        <li><a href="#电脑下棋的关键-min-max-对局搜寻与-alpha-beta-修剪算法">电脑下棋的关键： Min-Max 对局搜寻与 Alpha-Beta 修剪算法</a></li>
      </ul></li>
      <li><a href="#逻辑推论与专家系统">逻辑推论与专家系统</a><ul>
        <li><a href="#布林逻辑">布林逻辑</a></li>
        <li><a href="#谓词逻辑">谓词逻辑</a></li>
        <li><a href="#一阶逻辑">一阶逻辑</a></li>
        <li><a href="#二阶逻辑">二阶逻辑</a></li>
        <li><a href="#专家系统">专家系统</a></li>
        <li><a href="#实作布林逻辑的推论引擎">实作：布林逻辑的推论引擎</a></li>
        <li><a href="#实作专家系统---前向推论程式">实作：专家系统 - 前向推论程式</a></li>
        <li><a href="#实作专家系统---互动推论程式">实作：专家系统 - 互动推论程式</a></li>
        <li><a href="#实作谓词逻辑的推论引擎">实作：谓词逻辑的推论引擎</a></li>
      </ul></li>
      <li><a href="#结语-11">结语</a><ul>
        <li><a href="#ai-的梦想-1">AI 的梦想</a></li>
        <li><a href="#ai-的困境">AI 的困境</a></li>
        <li><a href="#未来展望">未来展望</a></li>
      </ul></li>
    </ul>
  </div>
  <h2 id="序"><a href="#序">序</a></h2>
  <p>人工智慧的书籍，往往理论眾多，看完之后却完全不知道怎麼实作。为了弥补这个缺陷，我们採用实作导向的方式，来说明人工智慧的各种理论，希望透过这些程式，让读者对抽象的理论能够有实际的感受。</p>
  <p>陈钟诚 2014/6/16 於 金门大学 资讯工程系</p>
  <h2 id="授权声明"><a href="#授权声明">授权声明</a></h2>
  <p>本课程内容由 <a href="http://ccckmit.wikidot.com/">金门大学</a> 创建，期中部分内容与图片来自 <a href="http://zh.wikipedia.org">维基百科</a>，因此採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">创作共用：姓名标示、相同方式分享</a> 之授权。</p>
  <p>若您想要修改本书產生衍生著作时，至少应该遵守下列授权条件：</p>
  <ol style="list-style-type: decimal">
    <li>标示原作者姓名为 <a href="http://ccckmit.wikidot.com/">陈钟诚</a> 衍生自 <a href="http://zh.wikipedia.org">维基百科</a> 的作品。</li>
    <li>採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/">创作共用：姓名标示、相同方式分享</a> 的方式公开衍生著作。</li>
  </ol>
  <h1 id="人工智慧简介"><a href="#人工智慧简介">人工智慧简介</a></h1>
  <blockquote>
    <p>玄之又玄、眾妙之门 -- 老子 道德经</p>
  </blockquote>
  <p>人工智慧 AI (Artificial Intelligence) 领域，可以说是资讯科学界的圣杯，或者说，更像是魔戒。这个令人想像就足以感到目眩神迷的领域，吸引了一代又一代的资讯科学研究者，不断的投入这些令人望而生畏的问题当中。不知是因为勇气还是利慾薰心，资讯科学研究者在此领域当中勇往直前，不断失败却前仆后继。许多人投入了一辈子，却没有得到想像中的成果，甚至连门口都没进去，就已经阵亡了。人工智慧领域的理论已经成为一个庞然大物，想入门的人在看到这样一个盘根错节的硕大的身躯时，往往还没到门口，就已经迷路了。而其他的人呢？则是在进了门之后，找不到出去的路。</p>
  <p>「仰之弥高，钻之弥坚，瞻之在前，忽焉在后」，这句被用来形容孔子的话，我觉得用来形容「人工智慧」会更为贴切一些。往往当研究者认为自己已经看到某些解答时，最后只发现了原来是一场梦。当问题看来如此的简单之时，其实门内躲了一个妖精或怪兽，正虎视眈眈的看著你，他们打算先引你进来再吃掉你。在人工智慧领域迷路的人，通常不是被怪兽吃掉，而是被妖精用美色迷惑。最后，以为自己到了天堂，其实是精尽人亡后，下了地狱而不自知。如果你想看看这个妖精所在的世界，就请随我而来吧。</p>
  <p>研究 AI 的学者，或许更像金庸小说中侠客岛上的江湖人物一样，到了侠客岛之后就被那些精妙的武功祕及所迷住了，再也不愿意返回到原本的江湖中，毕生研究的武学也就毫无用处了。</p>
  <p>侠客岛上的人物，只看到秘笈中的文字，却看不见文字笔势上所蕴含的图像式武学，因而错失了真正精妙的武功之所在。或许，研究 AI 的学者也有同样的问题，总是沉迷在各种看似高深的算法当中，却又见树不见林，以致於无法看见整体的智慧是如何形成的，这恐怕是 AI 领域的研究者未来所必须面对的挑战。</p>
  <p>在本书中，我们虽然会介绍 AI 的主要理论，但是却希望读者能回到现实上，以实作感受 AI 这些方法的意义，而不是只有理论阐述。即使如此，笔者目前仍然没有任何能力，能告诉读者如何才能拿到那个圣杯，或许这个圣杯根本就不存在也说不定。</p>
  <h2 id="何谓人工智慧-ai"><a href="#何谓人工智慧-ai">何谓人工智慧 (AI) ?</a></h2>
  <p>终於到了我们为人工智慧下定义的时候了，我们认为，AI 的定义，与其用技术方式，不如用目标的方式定义更恰当。AI 的目标是企图模拟人类，建构出具有类似人类大脑的程式。这包含使用眼睛、耳朵、嘴巴、手脚、身体等器官的能力。</p>
  <p>因此，AI 的目标乃是模拟人类大脑，并利用电脑的眼睛 (摄影机)、耳朵 (麦克风)、嘴巴 (喇叭)、手脚与身体 (机器人)，取得外在世界的资讯，根据这些资讯进行类似人类的智慧型行为，像是影像辨识 (眼睛)、手写辨识 (眼睛)、语音辨识 (耳朵)、机器人控制 (手脚与身体) 等，都是典型的 AI 领域。当然，还有许多与感官无关的领域，像是电脑下棋、自然语言理解、机器翻译、知识工程等，这些都是与大脑的功能直接相关的领域，也是AI 领域当中的经典问题。</p>
  <p>AI 是以电脑程式模拟人类的智慧行为，包含眼睛、耳朵等感官的「听、说、读、写」，与大脑的「推理、理解、学习」，还有动作类的「手、脚、身体、控制」等行为。</p>
  <table>
    <thead>
    <tr class="header">
      <th align="left">模拟行为</th>
      <th align="left">相关应用</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
      <td align="left">感知</td>
      <td align="left">语音辨识 (耳朵)、影像辨识 (眼睛)、手写辩识(眼睛)、指纹辩识(眼睛)</td>
    </tr>
    <tr class="even">
      <td align="left">推理</td>
      <td align="left">专家系统、电脑游戏、电脑下棋、医疗诊断 (大脑)</td>
    </tr>
    <tr class="odd">
      <td align="left">理解</td>
      <td align="left">机器翻译、交谈系统 (大脑)</td>
    </tr>
    <tr class="even">
      <td align="left">学习</td>
      <td align="left">电脑下棋、专家系统、医疗诊断、辩识 (大脑)</td>
    </tr>
    <tr class="odd">
      <td align="left">动作</td>
      <td align="left">机器人足球赛、自动驾驶、商用机器人、智慧型控制器 (手脚身体)</td>
    </tr>
    </tbody>
  </table>
  <h2 id="ai-的方法"><a href="#ai-的方法">AI 的方法</a></h2>
  <p>人工智慧的方法非常多样，早期的人工智慧研究聚焦在逻辑推论的方法，后来越来越多元化，像是类神经网路、模糊推论、遗传演算法、机率模型等都被包含进来。</p>
  <p>逻辑推论的方法，由於需要百分之百确定的事实配合，因此在实务上不容易使用，因此像模糊推论等方法，虽然在理论上较不优美，但是在实务上却很有用。类神经网路则是在影像辨识、语音辨识等领域，表现得较为杰出。</p>
  <p>近来，机率式的方法开始越来越受到重视，像是 Hidden Markov Model (HMM)、Bayes Network、Monte Carlo Marko Chain (MCMC)、Expectation-Maximization (EM) 等方法，都有越来越多的应用。举例而言，HMM 在语音辨识上具有非常好的辨识率、而 EM 学习演算法则在机器翻译上被大量的使用。</p>
  <p>由於机率式的方法在数学理论上较为完备，因此有更多的数学工具可以使用，因此未来人工智慧与数学的关係应该会越来越密切，这个领域将有待数学背景强的新研究者加入与探索，以便创造出更好的数学模型，让 AI 成为一门「真正的科学」。</p>
  <p>为了让电脑实现上述的智慧型功能，研究者这几十年来发展出了以下的方法，这些方法有些只适用於少数应用，而有些则可以适用於很多类的应用。</p>
  <table>
    <thead>
    <tr class="header">
      <th align="left">分类</th>
      <th align="left">方法</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
      <td align="left">搜寻</td>
      <td align="left">DFS, BFS, Best-FS, A*, Min-Max+α-β Cut, Dynamic Programming,</td>
    </tr>
    <tr class="even">
      <td align="left">最佳化</td>
      <td align="left">Greedy Algorithm, Simulate Annealing, Genetic Algorithm</td>
    </tr>
    <tr class="odd">
      <td align="left">逻辑推论</td>
      <td align="left">Boolean Logic, First-Order Logic, Probabilistic Logic, Fuzzy Logic</td>
    </tr>
    <tr class="even">
      <td align="left">神经网路</td>
      <td align="left">Back Propagation Network, Hopfield Network</td>
    </tr>
    <tr class="odd">
      <td align="left">机率统计</td>
      <td align="left">Bayesian Network, Hidden Markov Model, EM algorithm</td>
    </tr>
    <tr class="even">
      <td align="left">比对</td>
      <td align="left">Pattern Matching, Regular Expression, …</td>
    </tr>
    </tbody>
  </table>
  <p>尽管我们对 AI技术的期待越来越往后延，但是，这并不代表 AI 的方法越来越落后。相反的，理论不断的创新，而且越来越具有实务性。AI 理论已经是资讯科学领域当中最为庞大的一个分支，任何的教科书想要全面介绍这些理论，都彷彿是在完成不可能的任务。</p>
  <h3 id="搜寻法"><a href="#搜寻法">搜寻法</a></h3>
  <p>搜寻法一直是 AI 研究的主要方法，但是很少人会将逻辑推论与类神经网路也视为一种搜寻法。然而，近来的发展显示，用搜寻法的观点，可以很清楚的看出每一个方法都优缺点，其他的各种方法也都可以用搜寻法的角度，进行理论上的分析。</p>
  <p>许多无法归类到逻辑推论与类神经网路的方法，像是 <em>「贪婪式演算法、模拟退火法、遗传演算法、鸟群演算法、蚁群演算法」</em> 等等，都是在进行搜寻工作。</p>
  <h3 id="逻辑推论"><a href="#逻辑推论">逻辑推论</a></h3>
  <p>有些 AI 研究人员认为可以将全世界的知识，透过逻辑叙述的方式累积，然后利用这些知识进行推论，这便是知识工程或专家系统的任务。此种方式企图直接解答智慧之谜，其研究方法上认为『知识 = 智慧』。</p>
  <p>从早期的「布林逻辑、洪氏逻辑、一阶逻辑」等确定性的逻辑系统开始，发展出了「计划系统、专家系统」等模拟大脑推理行为的系统，这让逻辑推论成为了人工智慧的核心方法，但由於这些推理方法需要建构在 100% 确定的事实，并依赖 100% 确定的推理法则才能进行，因此在复杂的现实事件通常很难使用。</p>
  <p>后来的 AI 研究逐渐导向「非确定性」的推论方法上，像是「模糊推论、机率推论」等方法，这些推理方法比较能够在「现实世界」中有效的运用，因此近来的人工智慧研究者大多採用这类的方法近型更深入的研究。</p>
  <h3 id="类神经网路"><a href="#类神经网路">类神经网路</a></h3>
  <p>类神经在 1986 年之后，开始吸引了许多研究者的目光，原因是此类方法在语音与影像识别上，具有优秀的表现，将手写辨识与语音识别等问题的正确率拉到了 80 % 左右。这使得这个曾经被 Malvin Minsky 这位类神经先驱证明为不可行的方法 成为当红炸子鸡。</p>
  <p>现在，我们知道，类神经网路在影像辨识、语音识别等领域上表现很好，但是，类神经网路在符号式的领域，像是自然语言与机器翻译上，就显得力有未逮，甚至是格格不入了。</p>
  <p>其实，逻辑推论与类神经网路，都可以视为搜寻方法的一种特例。因为，这些方法都是在搜寻问题的答案，然而在问题的表达上，布林逻辑堆论採用了二分法，也就是只有 0 与 1 的世界。而类神经网路，则採用了实数的方式表达神经元之间的强度，於是造成了一个由实数所构成的世界。这两者并非是互斥的，或许，在未来，我们会发现两者携手合作的研究陆续出现。</p>
  <h3 id="机率统计"><a href="#机率统计">机率统计</a></h3>
  <p>机率统计方法在其他领域通常很快就成为主流方法，但是在 AI 领域却经过了很久都没受到重视，直到最近由於隐马可夫模型 (HMM) 逐渐在语音辨识领域崭露头角，才开始有越来越兴盛的趋势。最近，统计方法在机器翻译上有越来越强的趋势，像是贝氏网路 (Bayisian Network)、期望最佳化学习法 (Expectation-Maximization, EM)、蒙地卡罗马可夫学习法 (Montecarlo Markov Chain, MCMC) 等，都开始展露其优势，相信在未来的几年，机率统计法将会在 AI 领域大展身手，推进整个 AI 科学技术的进展。</p>
  <h2 id="ai-的梦想"><a href="#ai-的梦想">AI 的梦想</a></h2>
  <p>长久以来，AI 一直是一个充满梦幻式魅力的领域，人们对 AI 有无数的幻想与憧憬。科幻小说当中的未来世界可以说是 AI 的远程目标。但是，我相信学术界的许多人对这个说法有很多批判。因为，梦想与科学似乎是两个极端，科学的动力来自於梦想，但是科学的发展却是一个排除梦想的过程。</p>
  <p>尽管科幻书籍当中早已述说过这种梦想千百回了，然而，梦想仍然是梦想。要实现这些梦想，仍是一条漫漫长路。或许，在我们有生之年，都还看不到下列情况，但是，这些想像中的情节却不断的吸引著 AI 研究者踏入这个领域。让我们以一个科幻小说式的场景说明这些 AI 的目标。</p>
  <p>『西元 2100 年，史丹利从家中起床，在吃完僕人玛莉 (一个机器人) 所准备的早餐之后，开著智慧型的汽车 (名为伙计)，前往他上班的地点，MIT 的媒体实验室。与其说史丹利在开车，不如说他在车上继续睡觉。因为，伙计早就知道他上班的地点，因此，直接开到MIT 的媒体实验室后，用闹铃叫史丹利第二次起床，然后，自动开门让史丹利进入 MIT 媒体实验室的大门。</p>
  <p>在进入大门之后，媒体实验室的助理莉莎 (另一个机器人) 告诉史丹利，今天有一位中国籍学者 – 江明来访，打算与史丹利谈谈有关最近虚拟骇客入侵 MIT 虚拟世界，偷走巨额虚拟货币的事情。当学者江明到达时，说了一句『史丹利先生，您好!』，然后，江明嘴边的悬浮式透明麦克风，立刻将这句话翻译成英文的 “Hello ! Mr. Stanly，Nice to meet you !” 传送给史丹利耳中的讯息接收机，然后在史丹利先生的耳中播放出来。因此，虽然史丹利先生并不懂中文，但是，却可以与江明先生侃侃而谈。…』</p>
  <p>我们有必要就此停止故事情节继续发展下去，因为，再写下去这本书就变成科幻小说了。请读者回到 21 世纪初的现在，回到人工智慧教科书的主题中。如果我们想要实现上述的未来，那麼，我们到底现在应该要做甚麼呢？让我们逐项分析看看。</p>
  <p>玛莉 (机器人) 会做早餐，因此，他应该会移动、开冰箱、拿菜、开瓦斯、煮菜、拿碗、装菜、上菜等动作。为了达成这些动作，玛莉必须有控制其手脚的能力，这是典型的机器人控制问题。玛莉应该也需要具备视觉感官与影像辨识的能力，以避免发生撞到东西、煮菜时过熟烤焦等问题。同样的，伙计 (智慧型汽车) 也必须具备视觉辨识能力，以避免开车时撞到东西，并且能正确的将车开到 MIT 媒体实验室。莉莎 (机器人助理) 需要具备记忆力与语音合成的能力，以告诉史丹利其行程表。而学者江明嘴边的悬浮式透明麦克风，则需要具备语音识别与英汉自动翻译技术，才能将中文的语音，转换成英文的句子，传送给史丹利先生耳中的讯息接收机。而这台讯息接收机，则必须具备语音合成的能力，才能将这些讯息，转成语音拨放到史丹利先生的耳内，这些讯息甚至可能包含腔调与口音，才能让这个同步翻译过程更为逼真流畅。</p>
  <p>但是，我们必须先向读者说声抱歉，因为，这只是一段科幻场景，这些技术，我们现在通通都没有。这些梦幻式的能力，全都还在人类的想像当中。虽然，AI 学术界已经做了五十年以上的研究，然而，我们的影像辨识、语音识别、机器人控制、自然语言理解、机器翻译等技术，几乎全都还无法在现实生活上派上用场。但是，人类因为有梦想而伟大，我们仍然必须努力的作著这些梦，不管未来何时会实现，或者会不会实现，就像周星驰的名言 - 『没有梦想，那人活著和狗有甚麼不同』，或者更加激励人心的佐贺阿嘛的一句话 - 『有梦想总比没梦想好，就算到死的时候都还无法实现也没有关係。因为，那不过是个梦想而已』。</p>
  <h1 id="爬山演算法"><a href="#爬山演算法">爬山演算法</a></h1>
  <p>爬山演算法 (Hill Climbing) 是一种最简单的优化算法，该方法就像模拟人类爬山时的行为而设计的，因此称为爬山演算法。</p>
  <p>程式究竟要怎麼爬山呢？且让我们用一张图来看看。</p>
  <p>假如我们在 Google 里输入一个算式，Google 会帮我们画出该函数。举例而言，如果我在 Google 输入 <code>x^2+3x+5</code> 这个算式，您会看到下列图形：</p>
  <div class="figure">
    <img src="../img/GoogleGraph2D.jpg" alt="图、在 Google 输入 x^2+3x+5 后显示的函数图" /><p class="caption">图、在 Google 输入 x^2+3x+5 后显示的函数图</p>
  </div>
  <p>这时您可以移动滑鼠，图形会出现一个可移动的小蓝点，该点会沿著曲线移动，上图中 (x, y) 座标显示为 x:6.07202181, y:60.0855143， 就是那个小蓝点所在的位置。</p>
  <p>如果我们想要写程式寻找这个函数的最低点，那我们应该怎麼找呢？</p>
  <p>其实方法很简单，就是一直往低的地方走，一直走到最低点，然后你会看到左右两边都没办法更低了，於是就停止寻找，传回该最低点作为答案。</p>
  <p>这个方法，就像是水往低处流一样，不断的往更低的方向流，最后一定会流到一个山谷，然后就积成一个湖了。</p>
  <p>但是、既然这样，那为甚麼叫做爬山演算法，而不叫「流水下山演算法」呢？</p>
  <p>其实、只要反过来看就行了，如果我们想要找的是最高点，而不是最低点，那整个行为就会像爬山一样，只是最后爬到山顶就会停了。</p>
  <p>採用这种想法，若我们想找 <img src="../timg/b2a89b129682.jpg" /> 这个函数的最高，我们可以在 Google 输入 <code>-(x^2+3x+5)</code> 就可以看到那座山了，以下是 Google 显示的结果：</p>
  <div class="figure">
    <img src="../img/GoogleGraph2DMountain.jpg" alt="图、在 Google 输入 -(x^2+3x+5) 后显示的函数图" /><p class="caption">图、在 Google 输入 -(x^2+3x+5) 后显示的函数图</p>
  </div>
  <p>当然、如果函数有很多山峰，那这种方法只能走到小山丘就会停了。这时您可能会说，那为甚麼不再继续往更高的山走去呢？</p>
  <p>关於这点，并不是不行，只是程式没有眼睛，也没办法一眼望去把所有的地形都给看光，然后知道更高的山峰在哪裡？</p>
  <p>如果我们用上面水往低处流的想法，您就会清楚爬山演算法所遭遇的困难了。当您像水一样往下流，到了谷底之后，由於四周都是山壁，所以您根本看不到更低的谷到底在哪裡，所以只好就停下来了。</p>
  <p>此时、除非你爬出山谷，否则根本不可能找到更深的谷，这就是「流水下山演算法」所遭遇到的困难了。以下是我们用 Google 显示 <code>(x-5)*(x-3)*(2x+5)*(x+3)</code> 这个具有两个山谷的函数，所得到的图形。</p>
  <div class="figure">
    <img src="../img/GoogleGraph2D2vally.jpg" alt="图、两个山谷的情况，如何找到最低的山谷呢？" /><p class="caption">图、两个山谷的情况，如何找到最低的山谷呢？</p>
  </div>
  <p>假如我们在上图中左边的山谷，那麼怎麼能知道右边还有一个更低的山谷呢？这就是「流水下山演算法」的困难之所在了！</p>
  <p>当然、也有人试图提出一些企图找到更深的谷，或爬到更高的山的演算法，这些演算法往往是以爬山演算法为基础，然后再作一些改良，像是「模拟退火演算法」(Simulated Annealing Algorithm) 或大洪水演算法 (Great Deluge algorithm) 等等，这些方法都是企图让「流水下山演算法」有机会跳出山谷而设计的方法。</p>
  <p>当然、您也可以企图加上「冲力」之类的想法让「流水下山演算法」可以冲出低谷，但是到底要冲多久，还有该往哪个方向冲才对呢？那这种方法是否该改叫「冲山演算法」呢？</p>
  <p>当然、我是没有听过这种名称啦！</p>
  <p>另外、对於上述的单变数函数而言，不是往左边走就是往右边走，但是如果有两个变数，例如像 <code>x^2+y^2+3x+5y+6</code> ，但是只有一个山谷，那麼我们该修改哪个变数呢？举例而言，以下就是 Google 所画出的 <code>x^2+y^2+3x+5y+6</code> 之图形。</p>
  <div class="figure">
    <img src="../img/GoogleGraph3D.jpg" />
  </div>
  <p>在上述的双变数情形中，我们可以随机的挑一个变数，然后向左或向右移动一小步，只要移动后的点更低就接受，如果连续很多次移动都没办法找到更低的点，就认为已经到达山谷，这样的方法其实还蛮有效的，这种方法可以称为「随机下山演算法」 (反过来英文中以爬山的角度来看，所以称为随机爬山演算法 Stochastic Hill Climbing Algorithm)。</p>
  <p>当然、随机的方法有时会比较没效率，如果我们可以很容易的透过微积分计算斜率 (导数) 的话，那麼不管几个变数，我们都可以计算出山坡上最陡峭的那一个方向，这种微积分概念称为「梯度」，如下图所示：</p>
  <div class="figure">
    <img src="../img/Gradient.jpg" alt="图、曲面与每一点的梯度向量" /><p class="caption">图、曲面与每一点的梯度向量</p>
  </div>
  <p>在上图中，底下的平面上所画的向量，就是上面那个曲面在该点的梯度，换句话说某一点的梯度其实是一个向量。梯度的计算公式如下：</p>
  <div class="figure">
    <img src="../timg/4d0383fdb044.jpg" />
  </div>
  <p>如果我们可以计算某函数之梯度的话，那麼就可以不用透过随机的方式去乱走了，只要朝著梯度的方向走去，就是最快下降的道路了。</p>
  <p>如果我们採用这种沿著梯度方向往下走的方法，就称为「梯度下降法」(Gradient Descent)，这种方法可以说是一种「贪婪演算法」(Greedy Algorithm)，因为它每次都朝著最斜的方向走去，企图得到最大的下降幅度。</p>
  <p>在程式人杂誌上一期的焦点「神经网路」中的「反传递演算法」，其实就是一种梯度下降法，所以才会有下列这段程式：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">tanh</span>(x);
  }

  <span class="kw">function</span> <span class="fu">dsigmoid</span>(y) {
  <span class="kw">return</span> <span class="fl">1.0</span> - y*y;
  }</code></pre>
  <p>其中的 sigmoid(x) 设定为 tanh(x) 这个函数，tanh(x) 的数学定义如下：</p>
  <div class="figure">
    <img src="../timg/0a7a7dbd3516.jpg" />
  </div>
  <div class="figure">
    <img src="../timg/7621e383e2fc.jpg" />
  </div>
  <div class="figure">
    <img src="../timg/fb1e12546ddc.jpg" />
  </div>
  <p>而 dsigmoid(y) 中的 <code>1.0 - y*y</code> 则是 y=tanh(x) 的微分式，对每个 y=tanh(x) 都取微分式的时候，其实就是梯度的方向，因此「反传递演算法」事实上是一种梯度下降法啊！</p>
  <p>这时，或许各位会想起，「贪婪演算法」怎麼感觉有点熟悉，似乎在哪裡学过？</p>
  <p>如果各位学过演算法课程，或许想起像「最小扩展树」(Minimal Spanning Tree) 的演算法，您会想到这种方法也很贪婪，因为每次都找最小的边来加入，那也是一种「贪婪演算法」，但这与此处的贪婪演算法之概念显然有些差距了。</p>
  <h3 id="参考文献"><a href="#参考文献">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Great_Deluge_algorithm">Wikipedia:Great Deluge algorithm</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Simulated_annealing">Wikipedia:Simulated annealing</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Stochastic_hill_climbing">Wikipedia:Stochastic hill climbing</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Gradient_descent">Wikipedia:Gradient descent</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Greedy_algorithm">Wikipedia:Greedy algorithm</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">维基百科：爬山演算法</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">维基百科：模拟退火</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">维基百科：梯度下降法</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">维基百科：贪心法</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作以爬山演算法寻找函数最高点"><a href="#实作以爬山演算法寻找函数最高点">实作：以爬山演算法寻找函数最高点</a></h2>
  <h3 id="简介"><a href="#简介">简介</a></h3>
  <p>以下是「爬山演算法」 (Hill-Climbing Algorithm) 的一个简易版本，其方法超简单，就是一直看旁边有没有更好的解，如果有就移过去。然后反覆的作这样的动作，直到旁边的解都比现在的更差时，程式就停止，然后将那个位於山顶的解传回，就完成了。</p>
<pre><code>Algorithm HillClimbing(f, x)
  x = 随意设定一个解。
  while (x 有邻居 x&#39; 比 x 更高)
  x = x&#39;;
  end
  return x;
  end</code></pre>
  <p>当然、这种演算法只能找到「局部最佳解」(local optimal)，当整个空间有很多山顶的时候，这种方法会爬到其中一个山顶就停了，并不一定会爬到最高的山顶。</p>
  <h3 id="程式码"><a href="#程式码">程式码</a></h3>
  <p>档案： HillClimbingSimple.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="kw">function</span> <span class="fu">f</span>(x) { <span class="kw">return</span> -<span class="dv">1</span>*(x*x<span class="dv">+3</span>*x<span class="dv">+5</span>); }
  <span class="co">// function f(x) { return -1*Math.abs(x*x-4); }</span>

  <span class="kw">var</span> dx = <span class="fl">0.01</span>;

  <span class="kw">function</span> <span class="fu">hillClimbing</span>(f, x) {
  <span class="kw">while</span> (<span class="kw">true</span>) {
  <span class="fu">log</span>(<span class="st">&quot;f(%s)=%s&quot;</span>, <span class="ot">x</span>.<span class="fu">toFixed</span>(<span class="dv">4</span>), <span class="fu">f</span>(x).<span class="fu">toFixed</span>(<span class="dv">4</span>));
  <span class="kw">if</span> (<span class="fu">f</span>(x+dx) &gt;= <span class="fu">f</span>(x))
  x = x+dx;
  <span class="kw">else</span> <span class="kw">if</span> (<span class="fu">f</span>(x-dx) &gt;= <span class="fu">f</span>(x))
  x = x-dx;
  <span class="kw">else</span>
  <span class="kw">break</span>;
  }
  }

  <span class="fu">hillClimbing</span>(f, <span class="fl">0.0</span>);</code></pre>
  <h3 id="执行结果"><a href="#执行结果">执行结果</a></h3>
  <p>求解 : <img src="../timg/489e5db6d4d6.jpg" /> 的最高点，也就是 <img src="../timg/b2a89b129682.jpg" /> 的最低点。</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingSimple
  f(0.0000)=-5.0000
  f(-0.0100)=-4.9701
  f(-0.0200)=-4.9404
  f(-0.0300)=-4.9109
  f(-0.0400)=-4.8816
  f(-0.0500)=-4.8525
  ...
  f(-1.4500)=-2.7525
  f(-1.4600)=-2.7516
  f(-1.4700)=-2.7509
  f(-1.4800)=-2.7504
  f(-1.4900)=-2.7501
  f(-1.5000)=-2.7500</code></pre>
  <p>如果我们将上述程式的 f(x) 换成註解中的那个，也就是将 f(x) 换成如下版本：</p>
  <pre><code>function f(x) { return -1*Math.abs(x*x-4); }</code></pre>
  <p>那麼就可以用来求解 <img src="../timg/b2cb861ede12.jpg" /> 的最低点，也就是寻找 4 的平方根，以下是执行结果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingSimple
  f(0.0000)=-4.0000
  f(0.0100)=-3.9999
  f(0.0200)=-3.9996
  f(0.0300)=-3.9991
  f(0.0400)=-3.9984
  f(0.0500)=-3.9975
  ...
  f(1.9500)=-0.1975
  f(1.9600)=-0.1584
  f(1.9700)=-0.1191
  f(1.9800)=-0.0796
  f(1.9900)=-0.0399
  f(2.0000)=-0.0000</code></pre>
  <p>您可以看到上述程式正确的找到 4 的平方根是 2，而我们所用的方法与求解 <img src="../timg/489e5db6d4d6.jpg" /> 的最高点几乎是一模一样的，只是把函数换掉而已。</p>
  <h3 id="结语"><a href="#结语">结语</a></h3>
  <p>您可以看到上述用爬山演算法寻找函数最高点或最低点的程式，其实非常的简单，只不过是看看两边是否有更好的解，如果有就移过去罢了。</p>
  <p>但是、这麼简单的演算法，其实威力是非常强大的，这种方法可以求解的问题非常的多，很多人工智慧上非常重要的问题，其实都只不过是在进行函数优化的动作，也就是寻找某个函数的低点或高点而已，这些问题其实大部分都可以使用爬山演算法来求解。</p>
  <p>当然、要能寻找更复杂函数的「区域最佳解」，还必须进一步的对上述程式进行封装与抽象化，我们将在下一篇文章中解说将上述爬山程式抽象化后的版本，并用该程式来求更复杂函数的解。</p>
  <h3 id="参考文献-1"><a href="#参考文献-1">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">维基百科：爬山演算法</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作通用的爬山演算法架构"><a href="#实作通用的爬山演算法架构">实作：通用的爬山演算法架构</a></h2>
  <h3 id="前言"><a href="#前言">前言</a></h3>
  <p>在上一篇文章中，我们介绍了如何用 JavaScript 来寻找「单变数函数」的最高点。在这篇文章中，我们会将这个程式抽象化之后，成为一个通用的爬山演算法架构，以便能够寻找任何函数的最高点。</p>
  <h3 id="通用的爬山演算法架构"><a href="#通用的爬山演算法架构">通用的爬山演算法架构</a></h3>
  <p>档案：HillClimbing.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="kw">function</span>() {} <span class="co">// 爬山演算法的物件模版 (类别)</span>

  <span class="ot">hillClimbing</span>.<span class="ot">prototype</span>.<span class="fu">run</span> = <span class="kw">function</span>(s, maxGens, maxFails) { <span class="co">// 爬山演算法的主体函数</span>
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;s=%s&quot;</span>, s); <span class="co">// 印出初始解</span>
  <span class="kw">var</span> fails = <span class="dv">0</span>;          <span class="co">// 失败次数设为 0</span>
  <span class="co">// 当代数 gen&lt;maxGen，且连续失败次数 fails &lt; maxFails 时，就持续尝试寻找更好的解。</span>
  <span class="kw">for</span> (<span class="kw">var</span> gens=<span class="dv">0</span>; gens&lt;maxGens &amp;&amp; fails &lt; maxFails; gens++) {
  <span class="kw">var</span> snew = <span class="ot">s</span>.<span class="fu">neighbor</span>();           <span class="co">// 取得邻近的解</span>
  <span class="kw">var</span> sheight = <span class="ot">s</span>.<span class="fu">height</span>();          <span class="co">// sheight=目前解的高度</span>
  <span class="kw">var</span> nheight = <span class="ot">snew</span>.<span class="fu">height</span>();       <span class="co">// nheight=邻近解的高度</span>
  <span class="kw">if</span> (nheight &gt;= sheight) {          <span class="co">// 如果邻近解比目前解更好</span>
  s = snew;                        <span class="co">//   就移动过去</span>
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;%d: %s&quot;</span>, gens, s);  <span class="co">//   印出新的解</span>
  fails = <span class="dv">0</span>;                       <span class="co">//   移动成功，将连续失败次数归零</span>
  } <span class="kw">else</span>                             <span class="co">// 否则</span>
  fails++;                         <span class="co">//   将连续失败次数加一</span>
  }
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;solution: %s&quot;</span>, s);      <span class="co">// 印出最后找到的那个解</span>
  <span class="kw">return</span> s;                            <span class="co">//   然后传回。</span>
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = hillClimbing;         <span class="co">// 将爬山演算法的类别匯出。</span></code></pre>
  <h3 id="抽象的解答类别"><a href="#抽象的解答类别">抽象的解答类别</a></h3>
  <p>档案：solution.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="kw">function</span>(v) { <span class="co">// 解答的物件模版 (类别)</span>
  <span class="kw">this</span>.<span class="fu">v</span> = v;                <span class="co">// 参数 v 为解答的资料结构</span>
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">step</span> = <span class="fl">0.01</span>;          <span class="co">// 每一小步预设走的距离</span>

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">height</span> = <span class="kw">function</span>() { <span class="co">// 爬山演算法的高度函数</span>
  <span class="kw">return</span> -<span class="dv">1</span>*<span class="kw">this</span>.<span class="fu">energy</span>();               <span class="co">// 高度 = -1 * 能量</span>
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = Solution;   <span class="co">// 将解答类别匯出。</span></code></pre>
  <h3 id="实例-1-求解平方根"><a href="#实例-1-求解平方根">实例 1 ：求解平方根</a></h3>
  <p>在此，我们将以求解 4 的平方根为例，测试一下上述演算法是否能够找到正确的解答。</p>
  <p>档案：solutionNumber.js (单变数函数，求平方根)</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入解答类别</span>

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 单变数解答的邻居函数。</span>
  <span class="kw">var</span> x = <span class="kw">this</span>.<span class="fu">v</span>, dx=<span class="kw">this</span>.<span class="fu">step</span>;               <span class="co">// x:解答 , dx : 移动步伐大小</span>
  <span class="kw">var</span> xnew = (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)?x+dx:x-dx; <span class="co">// 用乱数决定向左或向右移动</span>
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(xnew);                  <span class="co">// 建立新解答并传回。</span>
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函数</span>
  <span class="kw">var</span> x = <span class="kw">this</span>.<span class="fu">v</span>;                             <span class="co">// x:解答</span>
  <span class="kw">return</span> <span class="ot">Math</span>.<span class="fu">abs</span>(x*x<span class="dv">-4</span>);                     <span class="co">// 能量函数为 |x^2-4|</span>
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 将解答转为字串，以供印出观察。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 将解答类别匯出。</span></code></pre>
  <p>档案：hillClimbingNumber.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);        <span class="co">// 引入爬山演算法类别</span>
  <span class="kw">var</span> solutionNumber = <span class="fu">require</span>(<span class="st">&quot;./solutionNumber&quot;</span>);    <span class="co">// 引入平方根解答类别</span>

  <span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                         <span class="co">// 建立爬山演算法物件</span>
  <span class="co">// 执行爬山演算法 (从「解答=0.0」开始寻找, 最多十万代、失败一千次就跳出。</span>
  <span class="ot">hc</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionNumber</span>(<span class="fl">0.0</span>), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
  <p>执行结果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\optimize&gt;node hillClimbingNumber.js
  s=energy(0.000)=4.000
  0: energy(-0.010)=4.000
  2: energy(-0.020)=4.000
  3: energy(-0.030)=3.999
  10: energy(-0.040)=3.998
  12: energy(-0.050)=3.998
  ....
  366: energy(-1.910)=0.352
  371: energy(-1.920)=0.314
  375: energy(-1.930)=0.275
  380: energy(-1.940)=0.236
  382: energy(-1.950)=0.197
  388: energy(-1.960)=0.158
  389: energy(-1.970)=0.119
  391: energy(-1.980)=0.080
  392: energy(-1.990)=0.040
  394: energy(-2.000)=0.000
  solution: energy(-2.000)=0.000</code></pre>
  <p>您可以看到上述程式最后找到 4 的平方根为 -2，这算是对的，因为我们在能量函数中没有规定平方根必须是正的，如果要求要是正的，那就可以为负数加上一个惩罚函数就行了。</p>
  <h3 id="实例-2-多变数函数的最佳化"><a href="#实例-2-多变数函数的最佳化">实例 2 ：多变数函数的最佳化</a></h3>
  <p>在此，我们将以求解 <img src="../timg/9205615feebe.jpg" /> 这个函数的最低点，看看上述演算法对多变数函数是否能正常运作。</p>
  <p>档案：solutionArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入抽象的解答类别</span>

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 多变数解答的邻居函数。</span>
  <span class="kw">var</span> nv = <span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">slice</span>(<span class="dv">0</span>);                   <span class="co">// nv=v.clone()=目前解答的复製品</span>
  <span class="kw">var</span> i = <span class="ot">Math</span>.<span class="fu">floor</span>(<span class="ot">Math</span>.<span class="fu">random</span>()*<span class="ot">nv</span>.<span class="fu">length</span>);<span class="co">// 随机选取一个变数</span>
  <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)                    <span class="co">// 掷骰子决定要往左或往右移</span>
  nv[i] += <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">else</span>
  nv[i] -= <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(nv);                    <span class="co">// 传回新建的邻居解答。</span>
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函数</span>
  <span class="kw">var</span> x=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">0</span>], y=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">1</span>], z=<span class="kw">this</span>.<span class="fu">v</span>[<span class="dv">2</span>];
  <span class="kw">return</span> x*x<span class="dv">+3</span>*y*y+z*z<span class="dv">-4</span>*x<span class="dv">-3</span>*y<span class="dv">-5</span>*z<span class="dv">+8</span>;         <span class="co">// (x^2+3y^2+z^2-4x-3y-5z+8)</span>
  }

  <span class="kw">var</span> numbersToStr=<span class="kw">function</span>(array, precision) { <span class="co">// 将数字阵列转为字串的函数。</span>
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">array</span>.<span class="fu">length</span>; i++) {
  <span class="kw">if</span> (array[i]&gt;=<span class="dv">0</span>)
  rzStr+=<span class="st">&quot; &quot;</span>+array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  <span class="kw">else</span>
  rzStr+=array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  }
  <span class="kw">return</span> rzStr;
  }


  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 将解答转为字串的函数，以供列印用。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="fu">numbersToStr</span>(<span class="kw">this</span>.<span class="fu">v</span>, <span class="dv">3</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 将解答类别匯出。</span></code></pre>
  <p>档案： hillClimbingArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);      <span class="co">// 引入爬山演算法类别</span>
  <span class="kw">var</span> solutionArray = <span class="fu">require</span>(<span class="st">&quot;./solutionArray&quot;</span>);    <span class="co">// 引入多变数解答类别 (x^2+3y^2+z^2-4x-3y-5z+8)</span>

  <span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                       <span class="co">// 建立爬山演算法物件</span>
  <span class="co">// 执行爬山演算法 (从「解答(x,y,z)=(1,1,1)」开始寻找, 最多十万代、失败一千次就跳出。</span>
  <span class="ot">hc</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionArray</span>([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
  <p>执行结果</p>
<pre><code>s=energy( 1.000  1.000  1.000 )=1.000
  0: energy( 1.000  1.000  1.010 )=0.970
  1: energy( 1.000  1.000  1.020 )=0.940
  3: energy( 1.000  1.000  1.030 )=0.911
  8: energy( 1.000  1.000  1.040 )=0.882
  9: energy( 1.000  1.000  1.050 )=0.853
  ...
  889: energy( 2.000  0.500  2.450 )=-2.998
  894: energy( 2.000  0.500  2.460 )=-2.998
  907: energy( 2.000  0.500  2.470 )=-2.999
  917: energy( 2.000  0.500  2.480 )=-3.000
  920: energy( 2.000  0.500  2.490 )=-3.000
  924: energy( 2.000  0.500  2.500 )=-3.000
  solution: energy( 2.000  0.500  2.500 )=-3.000</code></pre>
  <p>您可以发现这个程式最后找到的解答是 (x, y, z)=(2, 0.5, 2.5)，其能量值为 -3，也就是高度值为 3。</p>
  <h3 id="实例-3-线性联立方程组求解"><a href="#实例-3-线性联立方程组求解">实例 3 ：线性联立方程组求解</a></h3>
  <p>本范例求解的线性联立方程组，可以用矩阵描述如下：</p>
  <div class="figure">
    <img src="../timg/c7c64bbfca16.jpg" />
  </div>
  <p>这种线性联立方程组，可以写为矩阵相乘的形式如下：</p>
  <div class="figure">
    <img src="../timg/fb18212e251c.jpg" />
  </div>
  <p>其中的 A 为矩阵、x 与 b 均为「列向量」。</p>
  <div class="figure">
    <img src="../timg/121a89b66301.jpg" />
  </div>
  <p>这类问题想要求的答案是 x 的值，也就是在 A 与 b 都已知的情况之下，求符合条件的 x 是多少？</p>
  <p>我们使用的测试范例如下：</p>
<pre><code>A=[[1,1],[1,-1]]
  B=[[5][1]]</code></pre>
  <p>也就是求下列方程组的解答。</p>
<pre><code>x1+x2=5
  x1-x2=1</code></pre>
  <p>以下是我们表示解答的程式码，其中引入了 matrix 这个矩阵相乘的函式库。</p>
  <p>档案：solutionEquations.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Matrix   = <span class="fu">require</span>(<span class="st">&quot;./matrix&quot;</span>);
  <span class="kw">var</span> Solution = <span class="fu">require</span>(<span class="st">&quot;./solution&quot;</span>);         <span class="co">// 引入抽象的解答类别</span>

  <span class="co">// A X = B ，求 X 是多少？  </span>
  <span class="co">// A=[[1,1],[1,-1]] B=[[5][1]]，也就是求：</span>
  <span class="co">//   x1+x2=5</span>
  <span class="co">//   x1-x2=1</span>
  <span class="co">// 的解答</span>

  <span class="kw">var</span> A = <span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,-<span class="dv">1</span>]]);
  <span class="kw">var</span> B = <span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">5</span>,<span class="dv">1</span>]]).<span class="fu">transpose</span>();

  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="ot">Solution</span>.<span class="fu">zero</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(<span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>));
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">neighbor</span> = <span class="kw">function</span>() {    <span class="co">// 多变数解答的邻居函数。</span>
  <span class="kw">var</span> nx = <span class="kw">new</span> <span class="fu">Matrix</span>(<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">m</span>);              <span class="co">// 复製目前解的矩阵</span>
  <span class="kw">var</span> i = <span class="ot">Math</span>.<span class="fu">floor</span>(<span class="ot">Math</span>.<span class="fu">random</span>()*<span class="ot">nx</span>.<span class="fu">rows</span>());<span class="co">// 随机选取一个变数</span>
  <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">random</span>() &gt; <span class="fl">0.5</span>)                    <span class="co">// 掷骰子决定要往左或往右移</span>
  <span class="ot">nx</span>.<span class="fu">m</span>[i][<span class="dv">0</span>] += <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">else</span>
  <span class="ot">nx</span>.<span class="fu">m</span>[i][<span class="dv">0</span>] -= <span class="kw">this</span>.<span class="fu">step</span>;
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Solution</span>(nx);                    <span class="co">// 传回新建的邻居解答。</span>
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">energy</span> = <span class="kw">function</span>() {      <span class="co">// 能量函数:计算 ||AX-B||，也就是 ||Y-B||</span>
  <span class="kw">var</span> X = <span class="kw">this</span>.<span class="fu">v</span>;
  <span class="kw">var</span> Y = <span class="ot">A</span>.<span class="fu">mul</span>(X);
  <span class="kw">return</span> <span class="ot">Y</span>.<span class="fu">sub</span>(B).<span class="fu">norm</span>();
  }

  <span class="ot">Solution</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {    <span class="co">// 将解答转为字串的函数，以供列印用。</span>
  <span class="kw">return</span> <span class="st">&quot;energy(&quot;</span>+<span class="kw">this</span>.<span class="ot">v</span>.<span class="fu">transpose</span>().<span class="fu">toString</span>().<span class="fu">replace</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;&quot;</span>)+<span class="st">&quot;)=&quot;</span>+<span class="kw">this</span>.<span class="fu">energy</span>().<span class="fu">toFixed</span>(<span class="dv">3</span>);
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = Solution;                    <span class="co">// 将解答类别匯出。</span></code></pre>
  <p>接著是爬山演算法的主体，我们从解答 <code>x=[0,0]</code> 开始寻找：</p>
  <p>档案：hillClimbingEquations.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> hillClimbing = <span class="fu">require</span>(<span class="st">&quot;./hillClimbing&quot;</span>);      <span class="co">// 引入爬山演算法类别</span>
  <span class="kw">var</span> solutionEquations = <span class="fu">require</span>(<span class="st">&quot;./solutionEquations&quot;</span>);    <span class="co">// 引入线性联立方程组解答类别</span>

  <span class="kw">var</span> hc = <span class="kw">new</span> <span class="fu">hillClimbing</span>();                       <span class="co">// 建立爬山演算法物件</span>
  <span class="co">// 执行爬山演算法 (从「解答 x=(0,0)」开始寻找, 最多十万代、失败一千次就跳出。</span>
  <span class="ot">hc</span>.<span class="fu">run</span>(<span class="ot">solutionEquations</span>.<span class="fu">zero</span>(), <span class="dv">100000</span>, <span class="dv">1000</span>);</code></pre>
  <p>最后我们列出整个矩阵相乘的函数库原始码：</p>
  <p>档案：matrix.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="kw">var</span> Matrix=<span class="kw">function</span>(mat) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">mat</span>.<span class="fu">length</span>; i++) {
  m[i] = mat[i].<span class="fu">slice</span>(<span class="dv">0</span>);
  }
  <span class="kw">this</span>.<span class="fu">m</span> = m;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">precision</span> = <span class="dv">3</span>;

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">toStr</span>=<span class="kw">function</span>(precision) {
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>, m = <span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++) {
  <span class="kw">var</span> rowStr = <span class="st">&quot;&quot;</span>
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
  rowStr += m[i][j].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  rzStr += <span class="st">&quot;[&quot;</span>+<span class="ot">rowStr</span>.<span class="fu">trim</span>()+<span class="st">&quot;]</span><span class="ch">\n</span><span class="st">&quot;</span>;
  }
  <span class="kw">return</span> rzStr;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">rows</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="ot">m</span>.<span class="fu">length</span>; }
  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">cols</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">m</span>[<span class="dv">0</span>].<span class="fu">length</span>; }
  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">toString</span>=<span class="kw">function</span>() { <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">toStr</span>(<span class="kw">this</span>.<span class="fu">precision</span>); }

  <span class="ot">Matrix</span>.<span class="fu">create</span>=<span class="kw">function</span>(rows, cols, value) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;rows; i++) {
  m[i] = [];
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;cols; j++)
  m[i][j] = value;
  }
  <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Matrix</span>(m);
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">transpose</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(m[<span class="dv">0</span>].<span class="fu">length</span>, <span class="ot">m</span>.<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++) {
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>;j++)
  <span class="ot">r</span>.<span class="fu">m</span>[j][i] = m[i][j];
  }
  <span class="kw">return</span> r;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">mul</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>, m2=<span class="ot">mat2</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="ot">m</span>.<span class="fu">length</span>, m2[<span class="dv">0</span>].<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;m2[j].<span class="fu">length</span>; k++)
  <span class="ot">r</span>.<span class="fu">m</span>[i][k] += m[i][j]*m2[j][k];
  <span class="kw">return</span> r;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">add</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">var</span> m = <span class="kw">this</span>.<span class="fu">m</span>, m2 = <span class="ot">mat2</span>.<span class="fu">m</span>;
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="ot">m</span>.<span class="fu">length</span>, m[<span class="dv">0</span>].<span class="fu">length</span>, <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
  <span class="ot">r</span>.<span class="fu">m</span>[i][j] = m[i][j]+m2[i][j];
  <span class="kw">return</span> r;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">sub</span>=<span class="kw">function</span>(mat2) {
  <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">add</span>(<span class="ot">mat2</span>.<span class="fu">neg</span>());
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">sum</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> s=<span class="dv">0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
  s += m[i][j];
  <span class="kw">return</span> s;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">norm</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> s=<span class="dv">0</span>, m=<span class="kw">this</span>.<span class="fu">m</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">m</span>.<span class="fu">length</span>; i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;m[i].<span class="fu">length</span>; j++)
  s += m[i][j]*m[i][j];
  <span class="kw">return</span> s;
  }

  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">neg</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> r = <span class="ot">Matrix</span>.<span class="fu">create</span>(<span class="kw">this</span>.<span class="fu">rows</span>(), <span class="kw">this</span>.<span class="fu">cols</span>(), <span class="dv">0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">r</span>.<span class="ot">m</span>.<span class="fu">length</span>; i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="ot">r</span>.<span class="fu">m</span>[i].<span class="fu">length</span>; j++)
  <span class="ot">r</span>.<span class="fu">m</span>[i][j] = -<span class="dv">1</span>*<span class="kw">this</span>.<span class="fu">m</span>[i][j];
  <span class="kw">return</span> r;
  }

  <span class="ot">Matrix</span>.<span class="fu">test</span>=<span class="kw">function</span>() {
  <span class="kw">var</span> m1=<span class="kw">new</span> <span class="fu">Matrix</span>([[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]);
  <span class="kw">var</span> m2=<span class="ot">m1</span>.<span class="fu">transpose</span>();
  <span class="ot">Matrix</span>.<span class="ot">prototype</span>.<span class="fu">precision</span> = <span class="dv">0</span>;
  <span class="fu">log</span>(<span class="st">&quot;=====m1========</span><span class="ch">\n</span><span class="st">%s&quot;</span>, m1);
  <span class="fu">log</span>(<span class="st">&quot;=====m2========</span><span class="ch">\n</span><span class="st">%s&quot;</span>, m2);
  <span class="fu">log</span>(<span class="st">&quot;=====m1+m1=====</span><span class="ch">\n</span><span class="st">%s&quot;</span>, <span class="ot">m1</span>.<span class="fu">add</span>(m1));
  <span class="fu">log</span>(<span class="st">&quot;=====m1*m2=====</span><span class="ch">\n</span><span class="st">%s&quot;</span>, <span class="ot">m1</span>.<span class="fu">mul</span>(m2));
  }

  <span class="co">// Matrix.test();</span>

  <span class="ot">module</span>.<span class="fu">exports</span> = Matrix;</code></pre>
  <p>执行结果如下：</p>
<pre><code>s=energy([0.000 0.000])=26.000
  1: energy([0.000 0.010])=25.920
  5: energy([0.000 0.020])=25.841
  6: energy([0.000 0.030])=25.762
  7: energy([0.000 0.040])=25.683
  9: energy([0.010 0.040])=25.563
  ...
  655: energy([1.600 1.760])=4.035
  656: energy([1.600 1.770])=4.026
  659: energy([1.610 1.770])=3.970
  660: energy([1.620 1.770])=3.915
  661: energy([1.630 1.770])=3.860
  664: energy([1.640 1.770])=3.805
  665: energy([1.640 1.780])=3.796
  666: energy([1.640 1.790])=3.787
  ...
  1176: energy([2.970 2.000])=0.002
  1184: energy([2.980 2.000])=0.001
  1197: energy([2.990 2.000])=0.000
  1205: energy([3.000 2.000])=0.000
  solution: energy([3.000 2.000])=0.000</code></pre>
  <p>您可以看到最后找到的解为 <code>x=[3, 2]</code> ，这个结果确实是下列方程组的解答：</p>
<pre><code>x1+x2=5
  x1-x2=1</code></pre>
  <p>於是我们用这个爬山演算法的架构解决了线性联立方程组的求解问题。</p>
  <h3 id="结语-1"><a href="#结语-1">结语</a></h3>
  <p>当然、上述的架构不只可以解这些问题，甚至可以用来解像「线性规划、神经网路优化....」等等各式各样的问题，前提是您必须自行设计 solution 类别的 neighbor(), energy() 与 toString() 函数，然后写个主程式呼叫爬山演算法就行了。</p>
  <h3 id="参考文献-2"><a href="#参考文献-2">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Hill-climbing">Wikipedia:Hill climbing</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95">维基百科：爬山演算法</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作通用的模拟退火法架构"><a href="#实作通用的模拟退火法架构">实作：通用的「模拟退火法」架构</a></h2>
  <h3 id="前言-1"><a href="#前言-1">前言</a></h3>
  <p>在上一篇文章中，我们介绍了一个通用的爬山演算法架构，而模拟退火法其实是爬山演算法的一个改良版，其设计理念是参考打铁时金属从高温逐渐缓慢降温，可以让结构更紧緻的这种概念，在「流水下山演算法」上加入了温度的概念。</p>
  <p>当温度很高的时候，模拟退火法基本上就像随机乱走一样，但是当温度逐渐下降之后，模拟退火法就会逐渐凝固，只能朝著较好的解前进，向著较差解前进的机率会逐渐缩小。</p>
  <p>当温度几乎降到零的时候，模拟退火法基本上就会退化成爬山演算法，於是最后还是会固定在某个「区域最佳解」上面。但是由於经过从高温缓慢降温的过程，所以模拟退火法比较有机会在高温时跳出区域最佳解，然后找到更好的解，甚至是全域最佳解之后才凝固，这就是「模拟退火法」的设计原理了。</p>
  <p>以下是模拟退火法的演算法的简要写法：</p>
<pre><code>Algorithm SimulatedAnnealing(s)
  while (温度还不够低，或还可以找到比 s 更好的解 s&#39; 的时候)
  根据能量差与温度，用机率的方式决定是否要移动到新解 s&#39;。
  将温度降低一些
  end
  end  </code></pre>
  <p>在上述演算法中，所谓的机率的方式，是採用 <img src="../timg/658cc096866d.jpg" /> 这个机率公式，去判断是否要从 s 移动到 s'，其中 e 是 s 的能量值，而 e' 是 s' 的能量值。</p>
  <p>接著，就让我们来实作一个通用的模拟退火法架构吧 (与前述爬山演算法共用的「解答表示」solution 部份，我们就不再重复贴出了)</p>
  <h3 id="通用的模拟退火法架构"><a href="#通用的模拟退火法架构">通用的模拟退火法架构</a></h3>
  <p>档案：simulatedAnnealing.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="kw">function</span>() {}       <span class="co">// 模拟退火法的物件模版 (类别)</span>

  <span class="ot">simulatedAnnealing</span>.<span class="ot">prototype</span>.<span class="fu">P</span> = <span class="kw">function</span>(e, enew, T) { <span class="co">// 模拟退火法的机率函数</span>
  <span class="kw">if</span> (enew &lt; e)
  <span class="kw">return</span> <span class="dv">1</span>;
  <span class="kw">else</span>
  <span class="kw">return</span> <span class="ot">Math</span>.<span class="fu">exp</span>((e-enew)/T);
  }

  <span class="ot">simulatedAnnealing</span>.<span class="ot">prototype</span>.<span class="fu">run</span> = <span class="kw">function</span>(s, maxGens) { <span class="co">// 模拟退火法的主要函数</span>
  <span class="kw">var</span> sbest = s;                              <span class="co">// sbest:到目前为止的最佳解</span>
  <span class="kw">var</span> ebest = <span class="ot">s</span>.<span class="fu">energy</span>();                     <span class="co">// ebest:到目前为止的最低能量</span>
  <span class="kw">var</span> T     = <span class="dv">100</span>;                            <span class="co">// 从 100 度开始降温</span>
  <span class="kw">for</span> (<span class="kw">var</span> gens=<span class="dv">0</span>; gens&lt;maxGens; gens++) {    <span class="co">// 迴圈，最多作 maxGens 这麼多代。</span>
  <span class="kw">var</span> snew = <span class="ot">s</span>.<span class="fu">neighbor</span>();                  <span class="co">// 取得邻居解</span>
  <span class="kw">var</span> e    = <span class="ot">s</span>.<span class="fu">energy</span>();                    <span class="co">// e    : 目前解的能量</span>
  <span class="kw">var</span> enew = <span class="ot">snew</span>.<span class="fu">energy</span>();                 <span class="co">// enew : 邻居解的能量</span>
  T  = T * <span class="fl">0.999</span>;                           <span class="co">// 每次降低一些温度</span>
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">P</span>(e, enew, T) &gt; <span class="ot">Math</span>.<span class="fu">random</span>()) { <span class="co">// 根据温度与能量差掷骰子，若通过</span>
  s = snew;                               <span class="co">// 则移动到新的邻居解</span>
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;%d T=%s %s&quot;</span>, gens, <span class="ot">T</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">s</span>.<span class="fu">toString</span>()); <span class="co">// 印出观察</span>
  }
  <span class="kw">if</span> (enew &lt; ebest) {                       <span class="co">// 如果新解的能量比最佳解好，则更新最佳解。</span>
  sbest = snew;
  ebest = enew;
  }
  }
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;solution: %s&quot;</span>, <span class="ot">sbest</span>.<span class="fu">toString</span>()); <span class="co">// 印出最佳解</span>
  <span class="kw">return</span> sbest;                                  <span class="co">// 传回最佳解</span>
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = simulatedAnnealing;             <span class="co">// 将模拟退火演算法的类别匯出。</span></code></pre>
  <h3 id="实例求解平方根"><a href="#实例求解平方根">实例：求解平方根</a></h3>
  <p>在此，我们将以求解 4 的平方根为例，测试一下上述演算法是否能够找到正确的解答。</p>
  <p>档案：simulatedAnnealingNumber.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="fu">require</span>(<span class="st">&quot;./simulatedAnnealing&quot;</span>); <span class="co">// 引入模拟退火法类别</span>
  <span class="kw">var</span> solutionNumber = <span class="fu">require</span>(<span class="st">&quot;./solutionNumber&quot;</span>);         <span class="co">// 引入平方根解答类别</span>

  <span class="kw">var</span> sa = <span class="kw">new</span> <span class="fu">simulatedAnnealing</span>();                        <span class="co">// 建立模拟退火法物件</span>
  <span class="co">// 执行模拟退火法 (从「解答=0.0」开始寻找, 最多一万代。</span>
  <span class="ot">sa</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionNumber</span>(<span class="fl">0.0</span>), <span class="dv">10000</span>);</code></pre>
  <p>执行结果：</p>
<pre><code>0 T=99.900 energy(-0.010)=4.000
  1 T=99.800 energy(0.000)=4.000
  ...
  12 T=98.708 energy(-0.010)=4.000
  13 T=98.609 energy(-0.020)=4.000
  14 T=98.510 energy(-0.030)=3.999
  15 T=98.412 energy(-0.020)=4.000
  16 T=98.314 energy(-0.030)=3.999
  17 T=98.215 energy(-0.040)=3.998
  18 T=98.117 energy(-0.050)=3.998
  19 T=98.019 energy(-0.040)=3.998
  ...
  5072 T=0.625 energy(1.250)=2.437
  5073 T=0.624 energy(1.240)=2.462
  5074 T=0.624 energy(1.230)=2.487
  5075 T=0.623 energy(1.240)=2.462
  5076 T=0.622 energy(1.250)=2.437
  5077 T=0.622 energy(1.260)=2.412
  5078 T=0.621 energy(1.270)=2.387
  5079 T=0.620 energy(1.280)=2.362
  ...
  6615 T=0.133 energy(1.950)=0.197
  6617 T=0.133 energy(1.940)=0.236
  6618 T=0.133 energy(1.930)=0.275
  6619 T=0.133 energy(1.920)=0.314
  6620 T=0.133 energy(1.930)=0.275
  6621 T=0.133 energy(1.940)=0.236
  6622 T=0.133 energy(1.930)=0.275
  ...
  9377 T=0.008 energy(1.990)=0.040
  9378 T=0.008 energy(2.000)=0.000
  9396 T=0.008 energy(2.010)=0.040
  9397 T=0.008 energy(2.000)=0.000
  9528 T=0.007 energy(2.010)=0.040
  9531 T=0.007 energy(2.000)=0.000
  solution: energy(2.000)=0.000</code></pre>
  <p>您可以看到上述模拟退火法程式，在一开始的时候几乎都在乱走，因此浪费了很多时间，但也正是因为这种特性，模拟退火法比较有机会跳脱那些小山谷，而有机会找到更深的山谷，这正式模拟退火法的特性。</p>
  <p>虽然花的比较多的时间，但是模拟退火法最后还是正确的找到了 4 的平方根，传回了 2.000 的结果。</p>
  <h3 id="实例多变数函数的最佳化"><a href="#实例多变数函数的最佳化">实例：多变数函数的最佳化</a></h3>
  <p>在此，我们将以求解 <img src="../timg/9205615feebe.jpg" /> 这个函数的最低点，看看上述演算法对多变数函数是否能正常运作。</p>
  <p>档案：simulatedAnnealingArray.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> simulatedAnnealing = <span class="fu">require</span>(<span class="st">&quot;./simulatedAnnealing&quot;</span>); <span class="co">// 引入模拟退火法类别</span>
  <span class="kw">var</span> solutionArray = <span class="fu">require</span>(<span class="st">&quot;./solutionArray&quot;</span>);           <span class="co">// 引入多变数解答类别 (x^2+3y^2+z^2-4x-3y-5z+8)</span>

  <span class="kw">var</span> sa = <span class="kw">new</span> <span class="fu">simulatedAnnealing</span>();                        <span class="co">// 建立模拟退火法物件</span>
  <span class="co">// 执行模拟退火法 (从「解答(x,y,z)=(1,1,1)」开始寻找, 最多执行 2 万代。</span>
  <span class="ot">sa</span>.<span class="fu">run</span>(<span class="kw">new</span> <span class="fu">solutionArray</span>([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]), <span class="dv">20000</span>);</code></pre>
  <p>执行结果：</p>
<pre><code>0 T=99.900 energy( 1.000  1.000  0.990 )=1.030
  1 T=99.800 energy( 1.000  0.990  0.990 )=1.000
  2 T=99.700 energy( 1.000  0.980  0.990 )=0.971
  3 T=99.601 energy( 0.990  0.980  0.990 )=0.991
  4 T=99.501 energy( 0.990  0.990  0.990 )=1.021
  5 T=99.401 energy( 1.000  0.990  0.990 )=1.000
  6 T=99.302 energy( 1.000  0.990  1.000 )=0.970
  ...
  5985 T=0.251 energy( 0.870  1.260  1.770 )=0.543
  5986 T=0.250 energy( 0.870  1.250  1.770 )=0.497
  5987 T=0.250 energy( 0.870  1.250  1.760 )=0.512
  5988 T=0.250 energy( 0.870  1.250  1.750 )=0.527
  5989 T=0.250 energy( 0.870  1.250  1.760 )=0.512
  5990 T=0.249 energy( 0.860  1.250  1.760 )=0.535
  ...
  15036 T=0.000 energy( 2.000  0.500  2.510 )=-3.000
  15038 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
  15173 T=0.000 energy( 2.010  0.500  2.500 )=-3.000
  15174 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
  15261 T=0.000 energy( 2.000  0.500  2.490 )=-3.000
  15265 T=0.000 energy( 2.000  0.500  2.500 )=-3.000
  solution: energy( 2.000  0.500  2.500 )=-3.000</code></pre>
  <p>您可以看到，上述的模拟退火法程式，总共花了一万五千多代，终於找到了该多变数函数的谷底，虽然速度不快，但也总算是达成任务了。</p>
  <h3 id="结语-2"><a href="#结语-2">结语</a></h3>
  <p>当然，模拟退火法虽然比较有机会跳脱小山谷，去找到更深的山谷，但这并不表示模拟退火法一定可以找到最深的山谷。</p>
  <p>当温度已经降到很低的时后，模拟退火法就会逐渐凝固，於是就会固定在某个山谷不出来了。</p>
  <p>事实上、没有任何一种优化方法可以在「多项式时间内」保证找到任何函数的最低点，否则「NP-Complete」问题不就被解掉了，而「NP-Complete」问题事实上在计算理论领域裡，一直还是个最困难的未解之谜啊！</p>
  <h3 id="参考文献-3"><a href="#参考文献-3">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Simulated_annealing">Wikipedia:Simulated annealing</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB">维基百科：模拟退火</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h1 id="神经网路简介"><a href="#神经网路简介">神经网路简介</a></h1>
  <p>在电脑领域，神经网路是指一种模拟神经系统所设计出来的程式，用来模拟人类视觉、听觉等等智慧行为的原理，企图让电脑可以具有人类智慧的一种方法。</p>
  <p>下图是生物神经细胞的结构图，这个图看来颇为复杂，如果电脑程式真的要模拟这麼复杂的结构，那程式应该也会非常复杂才对。</p>
  <div class="figure">
    <img src="../img/NeuralCell.jpg" alt="图、神经细胞的结构" /><p class="caption">图、神经细胞的结构</p>
  </div>
  <p>还好、神经网路程式不需要去模拟「细胞膜、粒线体、核醣体」等等复杂的结构，因为学电脑的人可以透过「抽象化」这个伎俩，将上述的神经细胞结构简化成下图 (a) 的样子。</p>
  <p>在下图中，a1 ... an 是输入，w1 ... wn 是权重，这些输入乘上权重之后加总(SUM)，就会得到神经元的刺激强度，接著经过函数 f() 转换之后，就得到了输出的刺激强度。</p>
  <div class="figure">
    <img src="../img/NeuralNet1.jpg" alt="图、神经网路连接模型" /><p class="caption">图、神经网路连接模型</p>
  </div>
  <p>上图 (a)所对应的数学公式如下：</p>
  <div class="figure">
    <img src="../timg/5ced75ffc852.jpg" />
  </div>
  <p>其中的 b 值是用来作为门槛的阀值，举例而言，若 b 是 -0.5，那麼就代表要将总合减掉 0.5，才得到输入刺激强度，这可以用来调节刺激强度，才不会一直增强上去。</p>
  <p>而上图 (b) 中的网路，是一种单层的神经网路，所谓单层是不计算输入节点的计算方式，因此只有图中的大圈圈才算是一层，其中每个大圈圈都是如图 (a) 中的一个神经元。</p>
  <p>最早的神经网路程式称为感知器（Perceptron），这是由 Frank Rosenblatt 在 1957 年於 Cornell 航空实验室 (Cornell Aeronautical Laboratory) 所发明的。</p>
  <p>但是在 1969 年，Marvin Minsky 和 Seymour Papert 在《Perceptrons》书中，仔细分析了知器为的功能及局限，证明感知器不能解决简单的 XOR 等问题，结果导致神经网路技术经歷了长达 20 年的低潮期。</p>
  <p>后来在 1986 年，Rumelhart 等人於下列论文中提出「反向传播」(back-propagation) 演算法，并成功的被运用在语音辨识等领域之后，神经网路才又开始成为热门的研究主题。</p>
  <blockquote>
    <p>Rumelhart, David E.; Hinton, Geoffrey E., Williams, Ronald J. Learning representations by back-propagating errors. Nature. 8 October 1986, 323 (6088): 533–536.</p>
  </blockquote>
  <p>事实上、反向传播的方法，并不是 Rumelhart 等人第一个提出来的，Paul J. Werbos 1974 年在哈佛的博士论文中就提出了类似的方法，只是大家都不知道而已。</p>
  <blockquote>
    <p>Paul J. Werbos. Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences. PhD thesis, Harvard University, 1974</p>
  </blockquote>
  <p>当然、神经网路再度成为研究焦点之后，各式各样的方法又被发展出来了，大致上这些方法可以分为两类，一种称为「有指导者」的神经网路(Supervised Neural Network) ，像是「感知器与反传递演算法」等，另一种称为「没有指导者」的神经网路 (Unsupervised Neural Network)，像是「霍普菲尔德网路 (Hopfield Network) 与自组织神经网路 (Self Organization network)」等等。</p>
  <p>当然、神经网路并不是「神奇银弹」，可以解决人工智慧上的所有问题，神经网路最强大的地方是容错性很强，而且不需要像专家系统这样撰写一堆规则，但是有一得必有一失，神经网路自动学习完成之后，我们根本不知道该如何再去改进这个学习成果，因为那些权重对人类来说根本就没有什麼直观的意义，因此也就很难再去改进这个网路了。</p>
  <p>不过、程式能够自我学习毕竟是一件很神奇的事情，光是这点就值得让我们好好的去瞭解一下神经网路到底是怎麼运作的了！</p>
  <h3 id="参考文献-4"><a href="#参考文献-4">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Neuron">Wikipedia:Neuron</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Artificial_neuron">Wikipedia:Artificial neuron</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Artificial_neural_network">Wikipedia:Artificial neural network</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Perceptron">Wikipedia:Perceptron</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Backpropagation">Wikipedia:Backpropagation</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">维基百科：感知器</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">维基百科：人工神经网路</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E8%B5%AB%E5%B8%83%E7%90%86%E8%AE%BA">维基百科：赫布理论</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作单层感知器-perceptron"><a href="#实作单层感知器-perceptron">实作：单层感知器 (Perceptron)</a></h2>
  <h3 id="简介-1"><a href="#简介-1">简介</a></h3>
  <p>Rosenblatt 於 1958 年提出第一个神经网路模型，称为感知器，这个模型是基於 1943 年 McCulloch 与 Pitts 所提出的神经元模型，该模型的数学公式如下。</p>
  <div class="figure">
    <img src="../timg/1faa2e48aea6.jpg" />
  </div>
  <p>其中的 sign 是正负号判断函数，若是正数则传回 1，负数则传回 0。</p>
  <p>请注意，在此我们所说的「感知器」是指 Rosenblatt 当时所使用的感知器，特指只有一层节点的「单层感知器」，而不是指称那种具有隐藏层的「多层感知器」(Multilayer Perceptron)，这点必须特别澄清一下！</p>
  <p>而所谓感知器的学习，就是透过调整权重 wi 的方式，让整个网路可以学到某个函数的方法，所以权重的调整方法是整个感知器学习行为的核心。</p>
  <h3 id="感知器的学习"><a href="#感知器的学习">感知器的学习</a></h3>
  <p>那麼、我们要怎麼让神经网路学会某个函数呢？以下是感知器学习的演算法：</p>
  <ol style="list-style-type: decimal">
    <li><p>初始化：设定权重 <img src="../timg/c139ddae2765.jpg" /> 和临界值 <img src="../timg/2554a2bb846c.jpg" /> 的初值之范围为 [-0.5, 0.5]。</p></li>
    <li><p>激励：用输入 <img src="../timg/4ec0188cd431.jpg" /> 、权重 <img src="../timg/7f0e1a55880d.jpg" /> 与阀值 <img src="../timg/2554a2bb846c.jpg" /> 计算感知器的输出值 Y。</p>
      <ul>
        <li><img src="../timg/856b9cd80d94.jpg" title="fig:" /></li>
      </ul></li>
    <li><p>权重修改：根据函数输出 Yd 与感知器输出 Y 之间的差异，进行权重调整。</p>
      <ul>
        <li><p>3.1 计算误差 ： <img src="../timg/49e401d40cf4.jpg" /></p></li>
        <li><p>3.2 计算调整量： <img src="../timg/6fb8eb2fce33.jpg" /></p></li>
        <li><p>3.3 调整权重 ： <img src="../timg/d7d825c1b95d.jpg" /></p></li>
      </ul></li>
    <li><p>重复 2-3 步骤，直到学会为止 (如果一直学不会，只好宣告失败)。</p></li>
  </ol>
  <h3 id="感知器模型-两个输入的情况"><a href="#感知器模型-两个输入的情况">感知器模型 (两个输入的情况)</a></h3>
  <p>根据以上的方法，假如感知器的输入只有两个 <img src="../timg/9fb86666733f.jpg" /> 那麼权重也只会有两个 <img src="../timg/0a49adc5ecfb.jpg" /> ，於是我们可以得到下列的感知器模型：</p>
  <div class="figure">
    <img src="../img/perceptron.jpg" alt="图、两个输入的感知器模型" /><p class="caption">图、两个输入的感知器模型</p>
  </div>
  <p>假如我们的目标函数对於某组 (x1, x2) 的期望输出为 yd，那麼就可以计算出误差为 e=yd-y，於是我们可以透过下列方法调整权重。</p>
  <div class="figure">
    <img src="../timg/b1cacbe18ad7.jpg" />
  </div>
  <div class="figure">
    <img src="../timg/deff37e6fc5a.jpg" />
  </div>
  <p>可惜的是、上述的调整方法中，并没有调整到 <img src="../timg/2554a2bb846c.jpg" /> 值，如果我们想要连 <img src="../timg/2554a2bb846c.jpg" /> 值也一并设计成可浮动的，那麼就可以将 <img src="../timg/2554a2bb846c.jpg" /> 加入到 w 中，成为 w0，，并将 x0 设为 -1，如下图所示：</p>
  <div class="figure">
    <img src="../img/perceptron2.jpg" alt="图、调整简化后的感知器模型" /><p class="caption">图、调整简化后的感知器模型</p>
  </div>
  <p>经过上述的调整简化之后，我们只要在调整权重时加入下列这条，就可以连 <img src="../timg/2554a2bb846c.jpg" /> 也一併调整了。</p>
  <div class="figure">
    <img src="../timg/8e42fbb23320.jpg" />
  </div>
  <p>当我们对某布林函数「真值表」中的每一个输入，都反覆进行上述调整，最后是否能学会该「布林函数」呢？</p>
  <p>那麼、我们是否能够用这麼简单的方法让感知器学会 AND、OR 与 XOR 函数呢？</p>
  <p>如果可以的话，那麼我们能不能扩大到 n 输入的感知器上，让感知器学会任何一个布林函数呢？</p>
  <p>如果感知器可以学会任何一个布林函数，那就会具有强大的威力了！</p>
  <p>但可惜的是，这个问题的答案是否定的，虽然感知器可以学会 AND 与 OR，但是却不可能学会 XOR 函数。</p>
  <p>在说明这个问题的理论之前，先让我们透过实作来体会一下感知器是如何学习 AND 与 OR 函数的，然后感受一下感知器在学 XOR 函数时发生了甚麼问题？</p>
  <p>等到瞭解了程式的运作原理之后，我们再来说明为何感知器无法学会 XOR 函数。</p>
  <h3 id="感知器实作"><a href="#感知器实作">感知器实作</a></h3>
  <p>以下我们使用 JavaScript 程式实作出感知器，其程式码如下，您可以在 node.js 环境下执行此一程式：</p>
  <p>档案：perceptron.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="kw">var</span> Perceptron = <span class="kw">function</span>() { <span class="co">// 感知器物件</span>
  <span class="kw">this</span>.<span class="fu">step</span>=<span class="kw">function</span>(x, w) { <span class="co">// 步阶函数：计算目前权重 w 的情况下，网路的输出值为 0 或 1</span>
  <span class="kw">var</span> result = w[<span class="dv">0</span>]*x[<span class="dv">0</span>]+w[<span class="dv">1</span>]*x[<span class="dv">1</span>]+w[<span class="dv">2</span>]*x[<span class="dv">2</span>]; <span class="co">// y=w0*x0+x1*w1+x2*w2=-theta+x1*w1+x2*w2</span>
  <span class="kw">if</span> (result &gt;= <span class="dv">0</span>) <span class="co">// 如果结果大於零</span>
  <span class="kw">return</span> <span class="dv">1</span>;      <span class="co">//   就输出 1</span>
  <span class="kw">else</span>             <span class="co">// 否则</span>
  <span class="kw">return</span> <span class="dv">0</span>;      <span class="co">//   就输出 0</span>
  }

  <span class="kw">this</span>.<span class="fu">training</span>=<span class="kw">function</span>(truthTable) { <span class="co">// 训练函数 training(truthTable), 其中 truthTable 是目标真值表</span>
  <span class="kw">var</span> rate = <span class="fl">0.01</span>; <span class="co">// 学习调整速率，也就是 alpha</span>
  <span class="kw">var</span> w = [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ];
  <span class="kw">for</span> (<span class="kw">var</span> loop=<span class="dv">0</span>; loop&lt;<span class="dv">1000</span>; loop++) { <span class="co">// 最多训练一千轮</span>
  <span class="kw">var</span> eSum = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">truthTable</span>.<span class="fu">length</span>; i++) { <span class="co">// 每轮对於真值表中的每个输入输出配对，都训练一次。</span>
  <span class="kw">var</span> x = [ -<span class="dv">1</span>, truthTable[i][<span class="dv">0</span>], truthTable[i][<span class="dv">1</span>] ]; <span class="co">// 输入： x</span>
  <span class="kw">var</span> yd = truthTable[i][<span class="dv">2</span>];       <span class="co">// 期望的输出 yd</span>
  <span class="kw">var</span> y = <span class="kw">this</span>.<span class="fu">step</span>(x, w);  <span class="co">// 目前的输出 y</span>
  <span class="kw">var</span> e = yd - y;                  <span class="co">// 差距 e = 期望的输出 yd - 目前的输出 y</span>
  eSum += e*e;                     <span class="co">// 计算差距总和</span>
  <span class="kw">var</span> dw = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ];            <span class="co">// 权重调整的幅度 dw</span>
  dw[<span class="dv">0</span>] = rate * x[<span class="dv">0</span>] * e; w[<span class="dv">0</span>] += dw[<span class="dv">0</span>]; <span class="co">// w[0] 的调整幅度为 dw[0]</span>
  dw[<span class="dv">1</span>] = rate * x[<span class="dv">1</span>] * e; w[<span class="dv">1</span>] += dw[<span class="dv">1</span>]; <span class="co">// w[1] 的调整幅度为 dw[1]</span>
  dw[<span class="dv">2</span>] = rate * x[<span class="dv">2</span>] * e; w[<span class="dv">2</span>] += dw[<span class="dv">2</span>]; <span class="co">// w[2] 的调整幅度为 dw[2]</span>
  <span class="kw">if</span> (loop % <span class="dv">10</span> == <span class="dv">0</span>)
  <span class="fu">log</span>(<span class="st">&quot;%d:x=(%s,%s,%s) w=(%s,%s,%s) y=%s yd=%s e=%s&quot;</span>, loop,
  x[<span class="dv">0</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), x[<span class="dv">1</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), x[<span class="dv">2</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>),
  w[<span class="dv">0</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), w[<span class="dv">1</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>), w[<span class="dv">2</span>].<span class="fu">toFixed</span>(<span class="dv">3</span>),
  <span class="ot">y</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">yd</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>), <span class="ot">e</span>.<span class="fu">toFixed</span>(<span class="dv">3</span>));
  }
  <span class="kw">if</span> (<span class="ot">Math</span>.<span class="fu">abs</span>(eSum) &lt; <span class="fl">0.0001</span>) <span class="kw">return</span> w; <span class="co">// 当训练结果误差够小时，就完成训练了。</span>
  }
  <span class="kw">return</span> <span class="kw">null</span>; <span class="co">// 否则，就传会 null 代表训练失败。</span>
  }
  }

  <span class="kw">function</span> <span class="fu">learn</span>(tableName, truthTable) { <span class="co">// 学习主程式：输入为目标真值表 truthTable 与其名称 tableName。</span>
  <span class="fu">log</span>(<span class="st">&quot;================== 学习 %s 函数 ====================&quot;</span>, tableName);
  <span class="kw">var</span> p = <span class="kw">new</span> <span class="fu">Perceptron</span>();       <span class="co">// 建立感知器物件</span>
  <span class="kw">var</span> w = <span class="ot">p</span>.<span class="fu">training</span>(truthTable); <span class="co">// 训练感知器</span>
  <span class="kw">if</span> (w != <span class="kw">null</span>)                  <span class="co">// 显示训练结果</span>
  <span class="fu">log</span>(<span class="st">&quot;学习成功 !&quot;</span>);
  <span class="kw">else</span>
  <span class="fu">log</span>(<span class="st">&quot;学习失败 !&quot;</span>);
  <span class="fu">log</span>(<span class="st">&quot;w=%j&quot;</span>, w);
  }

  <span class="kw">var</span> andTable = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ] ]; <span class="co">// AND 函数的真值表</span>
  <span class="kw">var</span> orTable  = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ] ]; <span class="co">// OR  函数的真值表</span>
  <span class="kw">var</span> xorTable = [ [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ], [ <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> ], [ <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span> ] ]; <span class="co">// XOR 函数的真值表</span>

  <span class="fu">learn</span>(<span class="st">&quot;and&quot;</span>, andTable); <span class="co">// 学习 AND 函数</span>
  <span class="fu">learn</span>(<span class="st">&quot;or&quot;</span>,  orTable);  <span class="co">// 学习 OR  函数</span>
  <span class="fu">learn</span>(<span class="st">&quot;xor&quot;</span>, xorTable); <span class="co">// 学习 XOR 函数</span></code></pre>
  <p>执行结果</p>
<pre><code>D:\Dropbox\Public\web\ai\code&gt;node perceptron.js
  ================== 学习 and 函数 ====================
  0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
  0:x=(-1.000,0.000,1.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
  0:x=(-1.000,1.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
  0:x=(-1.000,1.000,1.000) w=(0.990,0.010,0.010) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,0.000,0.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,0.000,1.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,1.000,0.000) w=(0.900,0.100,0.100) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,1.000,1.000) w=(0.890,0.110,0.110) y=0.000 yd=1.000 e=1.000
  20:x=(-1.000,0.000,0.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
  20:x=(-1.000,0.000,1.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
  20:x=(-1.000,1.000,0.000) w=(0.800,0.200,0.200) y=0.000 yd=0.000 e=0.000
  20:x=(-1.000,1.000,1.000) w=(0.790,0.210,0.210) y=0.000 yd=1.000 e=1.000
  30:x=(-1.000,0.000,0.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
  30:x=(-1.000,0.000,1.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
  30:x=(-1.000,1.000,0.000) w=(0.700,0.300,0.300) y=0.000 yd=0.000 e=0.000
  30:x=(-1.000,1.000,1.000) w=(0.690,0.310,0.310) y=0.000 yd=1.000 e=1.000
  学习成功 !
  w=[0.6599999999999997,0.34000000000000014,0.34000000000000014]
  ================== 学习 or 函数 ====================
  0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
  0:x=(-1.000,0.000,1.000) w=(0.990,0.000,0.010) y=0.000 yd=1.000 e=1.000
  0:x=(-1.000,1.000,0.000) w=(0.980,0.010,0.010) y=0.000 yd=1.000 e=1.000
  0:x=(-1.000,1.000,1.000) w=(0.970,0.020,0.020) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,0.000,0.000) w=(0.700,0.200,0.200) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,0.000,1.000) w=(0.690,0.200,0.210) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,1.000,0.000) w=(0.680,0.210,0.210) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,1.000,1.000) w=(0.670,0.220,0.220) y=0.000 yd=1.000 e=1.000
  20:x=(-1.000,0.000,0.000) w=(0.460,0.340,0.340) y=0.000 yd=0.000 e=0.000
  20:x=(-1.000,0.000,1.000) w=(0.450,0.340,0.350) y=0.000 yd=1.000 e=1.000
  20:x=(-1.000,1.000,0.000) w=(0.440,0.350,0.350) y=0.000 yd=1.000 e=1.000
  20:x=(-1.000,1.000,1.000) w=(0.440,0.350,0.350) y=1.000 yd=1.000 e=0.000
  学习成功 !
  w=[0.37999999999999945,0.38000000000000017,0.38000000000000017]
  ================== 学习 xor 函数 ====================
  0:x=(-1.000,0.000,0.000) w=(1.000,0.000,0.000) y=0.000 yd=0.000 e=0.000
  0:x=(-1.000,0.000,1.000) w=(0.990,0.000,0.010) y=0.000 yd=1.000 e=1.000
  0:x=(-1.000,1.000,0.000) w=(0.980,0.010,0.010) y=0.000 yd=1.000 e=1.000
  0:x=(-1.000,1.000,1.000) w=(0.980,0.010,0.010) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,0.000,0.000) w=(0.800,0.100,0.100) y=0.000 yd=0.000 e=0.000
  10:x=(-1.000,0.000,1.000) w=(0.790,0.100,0.110) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,1.000,0.000) w=(0.780,0.110,0.110) y=0.000 yd=1.000 e=1.000
  10:x=(-1.000,1.000,1.000) w=(0.780,0.110,0.110) y=0.000 yd=0.000 e=0.000
  ...
  900:x=(-1.000,0.000,0.000) w=(0.010,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
  900:x=(-1.000,0.000,1.000) w=(-0.000,-0.010,0.010) y=0.000 yd=1.000 e=1.000
  900:x=(-1.000,1.000,0.000) w=(-0.010,-0.000,0.010) y=0.000 yd=1.000 e=1.000
  900:x=(-1.000,1.000,1.000) w=(-0.000,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
  ...
  990:x=(-1.000,0.000,0.000) w=(0.010,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
  990:x=(-1.000,0.000,1.000) w=(-0.000,-0.010,0.010) y=0.000 yd=1.000 e=1.000
  990:x=(-1.000,1.000,0.000) w=(-0.010,-0.000,0.010) y=0.000 yd=1.000 e=1.000
  990:x=(-1.000,1.000,1.000) w=(-0.000,-0.010,-0.000) y=1.000 yd=0.000 e=-1.000
  学习失败 !
  w=null</code></pre>
  <h3 id="分析"><a href="#分析">分析</a></h3>
  <p>您可以看到在上述执行结果中， AND 与 OR 两个真值表，输入到单层感知器进行训练之后，都可以正确的进行学习，也就是单层感知器的输出可以与该真值表完全一致，这代表单层感知器学习成功了。</p>
  <p>但是对於 XOR 这个真值表，单层感知器却无法让输出与真值表完全一致，这也正是 Minsky 所说的，单层感知器无法正确学习 XOR 函数的原因。</p>
  <p>会產生这个现象的原因，可以用线性代数的概念解释，下图显示了 AND, OR, XOR 等这三个真值表在二维线性空间的状况，其中的粉红色圆圈代表真值表的目标输出值为 1，而浅蓝色圆圈代表目标输出为 0。</p>
  <div class="figure">
    <img src="../img/perceptronLinearAnalysis.jpg" alt="图、单层感知器为何不能学习 XOR 函数的分析" /><p class="caption">图、单层感知器为何不能学习 XOR 函数的分析</p>
  </div>
  <p>您可以看到对於 AND 与 OR 都可以用一条线将「粉红色圆圈」与「浅蓝色圆圈」分割开来。但是对 XOR 而言，由於粉红色与浅蓝色分别处於斜对角，我们没有办法画出单一条线将两者分开，这也是会何上述单层感知器在学习 XOR 这个函数上会失败的原因了。</p>
  <h3 id="结语-3"><a href="#结语-3">结语</a></h3>
  <p>可惜的是，单层感知器并没有办法学会任意的布林函数，这个结果虽然令人失望，但是期望这麼简单的模型就能拥有强大的能力，其实是一种非常天真的想法。</p>
  <p>不过、如果我们将这种单层的网路继续扩充，变成双层以上的网路的话，其能力就会大大的提升了，这也就是我们接下来要探讨的主题，反传递演算法 (Back-Propagation Algorithm) 了。</p>
  <h3 id="参考文献-5"><a href="#参考文献-5">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Perceptron">Wikipedia:Perceptron</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">维基百科：感知器</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作多层感知器与反传递演算法"><a href="#实作多层感知器与反传递演算法">实作：多层感知器与反传递演算法</a></h2>
  <h3 id="前言-2"><a href="#前言-2">前言</a></h3>
  <p>在前一篇文章中，我们讨论了「单层感知器」的实作方式，然而单层感知器并没有办法处理像 XOR 这样的函数。</p>
  <p>为了提升「感知器」的能力，我们可以在输入与输出节点之间，再加入一些隐藏层，并透过这些隐藏层对整个学习空间进行更多次的分割，以便能处理 XOR 这类难以用单一线性函数分割的问题。</p>
  <p>但是加入了隐藏层之后，感知器的学习与训练就更为复杂了，这时必须有足够的「数学理论」才能为「多层感知器」提供一个方向，而「反传递演算法」 (Back-Propagation) 正是这样一个可以提供「多层感知器」学习方向的好东西，其数学基础则是建构在多变数微分「梯度」概念之上的一种「梯度下降法」。</p>
  <p>事实上、反传递演算法 (Back-Propagation) 的概念在 1974 年就由 Paul J. Werbos 所提出来了，但没有受到重视，后来在 1986 年又被 Rumelhart 重新发明了出来，而且受到了广泛的重视。</p>
  <p>在本文中，我们将说明「多层感知器」与「反传递演算法」的概念，并用 Node.js+JavaScript 进行实作。</p>
  <h3 id="模型与数学原理"><a href="#模型与数学原理">模型与数学原理</a></h3>
  <p>以下是本文程式所採用的一个「多层感知器」模型，其中包含「输入层、隐藏层与输出层」，这种多层感知器与上一篇「单层感知器」的一个明显不同点，在於拥有一个隐藏层，因此其能力增强了很多。</p>
  <div class="figure">
    <img src="../img/MLP.jpg" alt="图、多层感知器模型 (本图含一个隐藏层)" /><p class="caption">图、多层感知器模型 (本图含一个隐藏层)</p>
  </div>
  <p>既然反传递演算法是一种梯度下降法，那麼我们只要能计算出梯度的方向，就能让「多层感知器」的权重朝著能量下降最快的方向前进。</p>
  <p>但是、梯度要怎麼计算呢？先让我们来看一张多变数的能量曲线图。</p>
  <div class="figure">
    <img src="../img/Gradient.jpg" alt="图、曲面与每一点的梯度向量" /><p class="caption">图、曲面与每一点的梯度向量</p>
  </div>
  <p>在上图中，底下的平面上所画的向量，就是上面那个曲面在该点梯度的投影，指示了该平面最陡的下降方向。</p>
  <p>在直觉概念上，曲面上某一点的梯度，其实是曲面在该点切平面的法向量，梯度的计算公式如下：</p>
  <div class="figure">
    <img src="../timg/4d0383fdb044.jpg" />
  </div>
  <p>如果我们可以计算某函数之梯度的话，只要朝著梯度的方向走去，就是最快下降的道路了。</p>
  <p>採用这种沿著梯度方向往下走的方法，就称为「梯度下降法」(Gradient Descent)，这种方法可以说是一种「贪婪演算法」(Greedy Algorithm)，因为它每次都朝著最斜的方向走去，企图得到最大的下降幅度。</p>
  <p>为了要计算梯度，我们不能採用「单层感知器里的那种不可微分的 sign() 步阶函数」 (如下图 a 所示)，因为这样就不能用微积分的方式计算出梯度了，而必须改用可以微分的连续函数 sigmoid() (如下图 b 所示)，这样才能够透过微分计算出梯度。</p>
  <div class="figure">
    <img src="../img/MLP_neuron.jpg" alt="图、两种神经元之比较" /><p class="caption">图、两种神经元之比较</p>
  </div>
  <p>当我们改成可微分的 sigmoid() 函数之后，就可以运用微积分公式，事先求出其微分函数 dsigmoid() 。举例而言、在本文的程式中，我们就用了双曲正切函数 tanh(x) 作为 sigmoid() 函数，其定义如下所示：</p>
  <div class="figure">
    <img src="../timg/0a7a7dbd3516.jpg" />
  </div>
  <div class="figure">
    <img src="../timg/7621e383e2fc.jpg" />
  </div>
  <div class="figure">
    <img src="../timg/fb1e12546ddc.jpg" />
  </div>
  <p>由於 tanh(x) 的微分是 <img src="../timg/cd7b4072bc59.jpg" /> ，因此在下列这段程式中，我们定义了这些函数的计算方式。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> tanh=<span class="kw">function</span>(x) {
  <span class="kw">return</span> (<span class="ot">Math</span>.<span class="fu">exp</span>(x) - <span class="ot">Math</span>.<span class="fu">exp</span>(-x)) / (<span class="ot">Math</span>.<span class="fu">exp</span>(x) + <span class="ot">Math</span>.<span class="fu">exp</span>(-x));
  }

  <span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">return</span> <span class="fu">tanh</span>(x); <span class="co">// 表现较好</span>
  }

  <span class="kw">function</span> <span class="fu">dsigmoid</span>(x) {
  <span class="kw">return</span> <span class="fl">1.0</span> - x*x;
  }</code></pre>
  <p>上述程式中 dsigmoid(y) 中的 <code>1.0 - x*x</code> 则是 y=tanh(x) 的微分式，对每个 y=tanh(x) 都取微分式的时候，其实就是梯度的方向。</p>
  <p>(笔者註：有些实作会採用 <img src="../timg/ae4a7a4a574d.jpg" /> 作为 sigmoid() 函数，这与 tanh(x) 函数的形状非常类似，也是一种可行的方法)。</p>
  <h3 id="程式码-1"><a href="#程式码-1">程式码</a></h3>
  <p>档案：backprop.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Back-Propagation Neural Networks (JavaScript 版)</span>
  <span class="co">// 由陈钟诚修改自 Neil Schemenauer 的 Python 版</span>
  <span class="co">// Python 程式网址为： http://arctrix.com/nas/python/bpnn.py</span>

  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="co">// 建立大小为 n 的阵列并填入初始值 fill</span>
  <span class="kw">var</span> makeArray=<span class="kw">function</span>(n, fill) {
  <span class="kw">var</span> a = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;n; i++)
  <span class="ot">a</span>.<span class="fu">push</span>(fill);
  <span class="kw">return</span> a;
  }

  <span class="co">// 建立大小为 I*J 的矩阵并填入初始值 fill</span>
  <span class="kw">var</span> makeMatrix=<span class="kw">function</span>(I, J, fill) {
  <span class="kw">var</span> m = [];
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;I; i++)
  <span class="ot">m</span>.<span class="fu">push</span>(<span class="fu">makeArray</span>(J, fill));
  <span class="kw">return</span> m;
  }

  <span class="co">// numbersToStr():以精确度为 precision 个小数来输出阵列 array</span>
  <span class="kw">var</span> numbersToStr=<span class="kw">function</span>(array, precision) {
  <span class="kw">var</span> rzStr = <span class="st">&quot;&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="ot">array</span>.<span class="fu">length</span>; i++) {
  <span class="kw">if</span> (array[i]&gt;=<span class="dv">0</span>)
  rzStr+=<span class="st">&quot; &quot;</span>+array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  <span class="kw">else</span>
  rzStr+=array[i].<span class="fu">toFixed</span>(precision)+<span class="st">&quot; &quot;</span>;
  }
  <span class="kw">return</span> rzStr;
  }

  <span class="co">// rand():取得 a 到 b 之间的一个随机乱数</span>
  <span class="kw">var</span> rand=<span class="kw">function</span>(a, b) {
  <span class="kw">return</span> (b-a)*<span class="ot">Math</span>.<span class="fu">random</span>() + a;
  }

  <span class="co">// sigmoid(x)=tanh(x)</span>
  <span class="kw">function</span> <span class="fu">sigmoid</span>(x) {
  <span class="kw">var</span> tanh = (<span class="ot">Math</span>.<span class="fu">exp</span>(x) - <span class="ot">Math</span>.<span class="fu">exp</span>(-x)) / (<span class="ot">Math</span>.<span class="fu">exp</span>(x) + <span class="ot">Math</span>.<span class="fu">exp</span>(-x));
  <span class="kw">return</span> tanh; <span class="co">// 双曲正切函数</span>
  }

  <span class="co">// dsigmoid(x)=1-x^2;</span>
  <span class="co">// 参考：http://pynopticon.googlecode.com/svn/trunk/src/vlfeat/toolbox/special/dsigmoid.m</span>
  <span class="co">// 参考：http://en.wikipedia.org/wiki/Sigmoid_function</span>
  <span class="kw">function</span> <span class="fu">dsigmoid</span>(x) {
  <span class="kw">return</span> <span class="fl">1.0</span> - x*x;
  }

  <span class="kw">function</span> <span class="fu">NeuralNet</span>() {

  <span class="co">// init()：设定网路结构与权重的随机初始值的函数。</span>
  <span class="kw">this</span>.<span class="fu">init</span>=<span class="kw">function</span>(ni, nh, no) {
  <span class="co">// number of input, hidden, and output nodes</span>
  <span class="kw">this</span>.<span class="fu">ni</span> = ni + <span class="dv">1</span>; <span class="co">// +1 for bias node</span>
  <span class="kw">this</span>.<span class="fu">nh</span> = nh;
  <span class="kw">this</span>.<span class="fu">no</span> = no;

  <span class="co">// activations for nodes : 建立各层的节点阵列</span>
  <span class="kw">this</span>.<span class="fu">ai</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="fl">1.0</span>);
  <span class="kw">this</span>.<span class="fu">ah</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">1.0</span>);
  <span class="kw">this</span>.<span class="fu">ao</span> = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">1.0</span>);

  <span class="co">// create weights : 建立权重矩阵</span>
  <span class="kw">this</span>.<span class="fu">wi</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
  <span class="kw">this</span>.<span class="fu">wo</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);

  <span class="co">// set them to random vaules : 随机设定权重初始值。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++)
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
  <span class="kw">this</span>.<span class="fu">wi</span>[i][j] = <span class="fu">rand</span>(-<span class="fl">0.2</span>, <span class="fl">0.2</span>);
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++)
  <span class="kw">this</span>.<span class="fu">wo</span>[j][k] = <span class="fu">rand</span>(-<span class="fl">2.0</span>, <span class="fl">2.0</span>);

  <span class="co">// last change in weights for momentum  : 上一次的改变量矩阵，用来当动量以便爬过肩型区域。</span>
  <span class="kw">this</span>.<span class="fu">ci</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">ni</span>, <span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
  <span class="kw">this</span>.<span class="fu">co</span> = <span class="fu">makeMatrix</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);
  <span class="kw">return</span> <span class="kw">this</span>;
  }

  <span class="co">// update() : 计算网路的输出的函数</span>
  <span class="kw">this</span>.<span class="fu">update</span>=<span class="kw">function</span>(inputs) {
  <span class="co">// input activations : 设定输入值</span>
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span><span class="dv">-1</span>; i++)
  <span class="kw">this</span>.<span class="fu">ai</span>[i] = inputs[i];

  <span class="co">// hidden activations : 计算隐藏层输出值 ah[j]</span>
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
  <span class="kw">var</span> sum = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++)
  sum = sum + <span class="kw">this</span>.<span class="fu">ai</span>[i] * <span class="kw">this</span>.<span class="fu">wi</span>[i][j];
  <span class="kw">this</span>.<span class="fu">ah</span>[j] = <span class="fu">sigmoid</span>(sum);
  }

  <span class="co">// output activations : 计算输出层输出值 ao[k]</span>
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
  <span class="kw">var</span> sum = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++)
  sum = sum + <span class="kw">this</span>.<span class="fu">ah</span>[j] * <span class="kw">this</span>.<span class="fu">wo</span>[j][k];
  <span class="kw">this</span>.<span class="fu">ao</span>[k] = <span class="fu">sigmoid</span>(sum);
  }

  <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">ao</span>; <span class="co">// 传回输出层输出值 ao</span>
  }

  <span class="co">// backPropagate()：反传递学习的函数 (重要)</span>
  <span class="kw">this</span>.<span class="fu">backPropagate</span> = <span class="kw">function</span>(targets, rate, moment) {
  <span class="co">// calculate error terms for output : 计算输出层误差</span>
  <span class="kw">var</span> output_deltas = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">no</span>, <span class="fl">0.0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
  <span class="kw">var</span> error = targets[k]-<span class="kw">this</span>.<span class="fu">ao</span>[k];
  output_deltas[k] = <span class="fu">dsigmoid</span>(<span class="kw">this</span>.<span class="fu">ao</span>[k]) * error;
  }

  <span class="co">// calculate error terms for hidden : 计算隐藏层误差</span>
  <span class="kw">var</span> hidden_deltas = <span class="fu">makeArray</span>(<span class="kw">this</span>.<span class="fu">nh</span>, <span class="fl">0.0</span>);
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
  <span class="kw">var</span> error = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
  <span class="co">// 注意、在此输出层误差 output_deltas 会反传递到隐藏层，因此才称为反传递演算法。</span>
  error = error + output_deltas[k]*<span class="kw">this</span>.<span class="fu">wo</span>[j][k];
  }
  hidden_deltas[j] = <span class="fu">dsigmoid</span>(<span class="kw">this</span>.<span class="fu">ah</span>[j]) * error;
  }

  <span class="co">// update output weights : 更新输出层权重</span>
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="kw">this</span>.<span class="fu">no</span>; k++) {
  <span class="kw">var</span> change = output_deltas[k]*<span class="kw">this</span>.<span class="fu">ah</span>[j];
  <span class="kw">this</span>.<span class="fu">wo</span>[j][k] = <span class="kw">this</span>.<span class="fu">wo</span>[j][k] + rate*change + moment*<span class="kw">this</span>.<span class="fu">co</span>[j][k];
  <span class="kw">this</span>.<span class="fu">co</span>[j][k] = change;
  <span class="co">// print N*change, M*this.co[j][k]</span>
  }
  }

  <span class="co">// update input weights : 更新输入层权重</span>
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="fu">ni</span>; i++) {
  <span class="kw">for</span> (<span class="kw">var</span> j=<span class="dv">0</span>; j&lt;<span class="kw">this</span>.<span class="fu">nh</span>; j++) {
  <span class="kw">var</span> change = hidden_deltas[j]*<span class="kw">this</span>.<span class="fu">ai</span>[i];
  <span class="kw">this</span>.<span class="fu">wi</span>[i][j] = <span class="kw">this</span>.<span class="fu">wi</span>[i][j] + rate*change + moment*<span class="kw">this</span>.<span class="fu">ci</span>[i][j];
  <span class="kw">this</span>.<span class="fu">ci</span>[i][j] = change;
  }
  }

  <span class="co">// calculate error : 计算输出层误差总合</span>
  <span class="kw">var</span> error = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> k=<span class="dv">0</span>; k&lt;<span class="ot">targets</span>.<span class="fu">length</span>; k++)
  error = error + <span class="fl">0.5</span>*<span class="ot">Math</span>.<span class="fu">pow</span>(targets[k]-<span class="kw">this</span>.<span class="fu">ao</span>[k],<span class="dv">2</span>);
  <span class="kw">return</span> error;
  }

  <span class="co">// test() : 对真值表 (训练样本) 中的每个输入都印出「网路输出」与「期望输出」，以便观察学习结果是否都正确。</span>
  <span class="kw">this</span>.<span class="fu">test</span> = <span class="kw">function</span>(patterns) {
  <span class="kw">for</span> (<span class="kw">var</span> p <span class="kw">in</span> patterns) {
  <span class="kw">var</span> inputs = patterns[p][<span class="dv">0</span>];
  <span class="kw">var</span> outputs= patterns[p][<span class="dv">1</span>];
  <span class="fu">log</span>(<span class="st">&quot;%j -&gt; [%s] [%s]&quot;</span>, inputs, <span class="fu">numbersToStr</span>(<span class="kw">this</span>.<span class="fu">update</span>(inputs), <span class="dv">0</span>), <span class="fu">numbersToStr</span>(outputs, <span class="dv">0</span>));
  <span class="co">// this.dump();</span>
  }
  }

  <span class="co">// train(): 主要学习函数，反覆呼叫反传递算法</span>
  <span class="co">// 参数：rate: learning rate (学习速率), moment: momentum factor (动量常数)</span>
  <span class="kw">this</span>.<span class="fu">train</span>=<span class="kw">function</span>(patterns, iterations, rate, moment) {
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;iterations; i++) {
  <span class="kw">var</span> error = <span class="fl">0.0</span>;
  <span class="kw">for</span> (<span class="kw">var</span> p <span class="kw">in</span> patterns) {
  <span class="kw">var</span> pat=patterns[p];
  <span class="kw">var</span> inputs = pat[<span class="dv">0</span>];
  <span class="kw">var</span> targets = pat[<span class="dv">1</span>];
  <span class="kw">var</span> outputs = <span class="kw">this</span>.<span class="fu">update</span>(inputs);
  error = error + <span class="kw">this</span>.<span class="fu">backPropagate</span>(targets, rate, moment);
  }
  <span class="kw">if</span> (i % <span class="dv">100</span> == <span class="dv">0</span>)
  <span class="fu">log</span>(<span class="st">&#39;%d:error %j&#39;</span>, i, error);
  }
  }
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = NeuralNet; <span class="co">// 匯出 NeuralNet 物件。</span></code></pre>
  <h3 id="执行范例-1-学习-xor-函数"><a href="#执行范例-1-学习-xor-函数">执行范例 1 : 学习 XOR 函数</a></h3>
  <p>档案：backprop_xor.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> NN = <span class="fu">require</span>(<span class="st">&quot;./backprop&quot;</span>);

  pat = [
  [[<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>]],
  [[<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">1</span>]],
  [[<span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">1</span>]],
  [[<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>]]
  ];

  <span class="co">// create a network with two input, two hidden, and one output nodes</span>
  nn = <span class="kw">new</span> <span class="fu">NN</span>().<span class="fu">init</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>);
  <span class="co">// train it with some patterns</span>
  <span class="ot">nn</span>.<span class="fu">train</span>(pat, <span class="dv">1000</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>);
  <span class="co">// test it</span>
  <span class="ot">nn</span>.<span class="fu">test</span>(pat);</code></pre>
  <p>执行结果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\neural&gt;node backprop_xor
  0:error 1.1411586806597014
  100:error 0.15669092345306487
  200:error 0.0044566959936791035
  300:error 0.0018489705409186357
  400:error 0.0011477205633429219
  500:error 0.0008277968129286529
  600:error 0.0006456614467953627
  700:error 0.005231441443909679
  800:error 0.0004595906757934737
  900:error 0.0003945408066808508
  [0,0] -&gt; [ 0 ] [ 0 ]
  [0,1] -&gt; [ 1 ] [ 1 ]
  [1,0] -&gt; [ 1 ] [ 1 ]
  [1,1] -&gt; [-0 ] [ 0 ]</code></pre>
  <h3 id="执行范例-2-学习七段显示器函数"><a href="#执行范例-2-学习七段显示器函数">执行范例 2 : 学习七段显示器函数</a></h3>
  <p>档案：backprop_7seg.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/* 七段显示器排列图示</span>
  <span class="co">  A</span>
  <span class="co">F   B</span>
  <span class="co">  G</span>
  <span class="co">E   C</span>
  <span class="co">  D</span>
  <span class="co">*/</span>

  <span class="kw">var</span> NN = <span class="fu">require</span>(<span class="st">&quot;./backprop&quot;</span>);

  pat = [
  <span class="co">// A B C D E F G </span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 0</span>
  [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]], <span class="co">// 1</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]], <span class="co">// 2</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>]], <span class="co">// 3</span>
  [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 4</span>
  [[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]], <span class="co">// 5</span>
  [[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]], <span class="co">// 6</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]], <span class="co">// 7</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]], <span class="co">// 8</span>
  [[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>], [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]]  <span class="co">// 9</span>
  ];

  <span class="co">// create a network with 7 input, 5 hidden, and 4 output nodes</span>
  nn = <span class="kw">new</span> <span class="fu">NN</span>().<span class="fu">init</span>(<span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">4</span>);
  <span class="co">// train it with some patterns</span>
  <span class="ot">nn</span>.<span class="fu">train</span>(pat, <span class="dv">10000</span>, <span class="fl">0.2</span>, <span class="fl">0.01</span>);
  <span class="co">// test it</span>
  <span class="ot">nn</span>.<span class="fu">test</span>(pat);</code></pre>
  <p>执行结果：</p>
<pre><code>D:\Dropbox\Public\web\ai\code\neural&gt;node backprop_7seg
  0:error 21.80370718175807
  100:error 3.0996784544877736
  200:error 2.9554663137424373
  300:error 2.9322332121195545
  400:error 0.9175505320368402
  500:error 0.5911840202045504
  600:error 0.6702566860375645
  700:error 0.6175745429758741
  800:error 0.6073471516556047
  900:error 0.601200049561361
  1000:error 0.5810463514787689
  1100:error 0.5364677212922591
  1200:error 0.532025286869445
  1300:error 0.46666848524996085
  1400:error 0.48129628693742754
  1500:error 0.8155362088747744
  1600:error 0.5829386518767099
  1700:error 0.6944742612114545
  1800:error 0.49717362214697597
  1900:error 0.40957109669176334
  2000:error 0.5388564563993076
  2100:error 0.3703582901903478
  2200:error 0.5178647638260341
  2300:error 0.1764373289120007
  2400:error 0.25347246319196093
  2500:error 0.33310966813566406
  2600:error 0.17106878914718923
  2700:error 0.1365002209754472
  2800:error 0.1594051132697459
  2900:error 0.3070991793860354
  3000:error 0.3766039636947747
  3100:error 0.3555367190225767
  3200:error 0.11555541960454409
  3300:error 0.11367500949340971
  3400:error 0.12234128181753154
  3500:error 0.1675446667610037
  3600:error 0.09044262748000728
  3700:error 0.08628776394501735
  3800:error 0.27906234926518514
  3900:error 0.04818459875532369
  4000:error 0.062418918530088664
  4100:error 0.2804289611800696
  4200:error 0.13725495522690973
  4300:error 0.12719742994691247
  4400:error 0.07177660395615833
  4500:error 0.08548411758763816
  4600:error 0.03974217740792855
  4700:error 0.09595126476746213
  4800:error 0.03853494372617759
  4900:error 0.06360901767700806
  5000:error 0.07246959735102428
  5100:error 0.05362418748287888
  5200:error 0.04669033343340621
  5300:error 0.03270696475959521
  5400:error 0.03940008954106113
  5500:error 0.047208537352753516
  5600:error 0.049368429554604215
  5700:error 0.042625347453785954
  5800:error 0.056241589618292134
  5900:error 0.016798400589135128
  6000:error 0.03404851177897533
  6100:error 0.028972975396903942
  6200:error 0.01572555942490573
  6300:error 0.048110746037786964
  6400:error 0.039118552165591194
  6500:error 0.03954060666366999
  6600:error 0.047240563507126423
  6700:error 0.013729342899560402
  6800:error 0.03734015049471263
  6900:error 0.04385222818693631
  7000:error 0.038098235270263764
  7100:error 0.014325393180305138
  7200:error 0.039093361005808284
  7300:error 0.011914229228792664
  7400:error 0.012490068609142688
  7500:error 0.010110888778014877
  7600:error 0.017266400583083073
  7700:error 0.037972260655506615
  7800:error 0.010317947862704183
  7900:error 0.02181165885044425
  8000:error 0.033354842242808616
  8100:error 0.033244707069915634
  8200:error 0.02269772865101642
  8300:error 0.008219315372175379
  8400:error 0.03342460798252796
  8500:error 0.008080093519395289
  8600:error 0.02466937317542233
  8700:error 0.03307092886686206
  8800:error 0.033433889409569414
  8900:error 0.031423007039930506
  9000:error 0.018154152094468162
  9100:error 0.008635680953338276
  9200:error 0.030890671102892397
  9300:error 0.009020762345545542
  9400:error 0.015823853695083934
  9500:error 0.029353956299920176
  9600:error 0.03028116871034789
  9700:error 0.03009059907189612
  9800:error 0.025996249652393937
  9900:error 0.009595759182954272
  [1,1,1,1,1,1,0] -&gt; [ 0  0 -0 -0 ] [ 0  0  0  0 ]
  [0,1,1,0,0,0,0] -&gt; [ 0 -0 -0  1 ] [ 0  0  0  1 ]
  [1,1,0,1,1,0,1] -&gt; [-0 -0  1  0 ] [ 0  0  1  0 ]
  [1,1,1,1,0,0,1] -&gt; [-0  0  1  1 ] [ 0  0  1  1 ]
  [0,1,1,0,0,1,1] -&gt; [ 0  1 -0  0 ] [ 0  1  0  0 ]
  [1,0,1,1,0,1,1] -&gt; [-0  1 -0  1 ] [ 0  1  0  1 ]
  [1,0,1,1,1,1,1] -&gt; [-0  1  1  0 ] [ 0  1  1  0 ]
  [1,1,1,0,0,0,0] -&gt; [-0  1  1  1 ] [ 0  1  1  1 ]
  [1,1,1,1,1,1,1] -&gt; [ 1 -0 -0  0 ] [ 1  0  0  0 ]
  [1,1,1,1,0,1,1] -&gt; [ 1  0 -0  1 ] [ 1  0  0  1 ]</code></pre>
  <h3 id="结语-4"><a href="#结语-4">结语</a></h3>
  <p>您可以看到上述两个训练案例，都是完全正确的，这代表反传递演算法可以让多层感知器学会 XOR 与七段显示器的函数。</p>
  <p>当然、多层感知器也可以学会更难的问题，像是手写的数字与英文字辨认等等，手写中文辨认和语音辨认当然也是可行的，只不过需要很多的训练范例与节点，学习的效果才会够好就是了！</p>
  <h3 id="参考文献-6"><a href="#参考文献-6">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Backpropagation">Wikipedia:Backpropagation</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Multilayer_perceptron">Wikipedia:Multilayer perceptron</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95">维基百科:反向传播演算法</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA">维基百科:多层感知机</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="图形搜寻简介"><a href="#图形搜寻简介">图形搜寻简介</a></h2>
  <h3 id="简介-2"><a href="#简介-2">简介</a></h3>
  <p>在离散数学、演算法与人工智慧的领域，很多问题可以表示为「节点与连线所形成的图形」，一个程式要解决某问题其实是在这个图形里把目标节点给找出来，於是问题求解就简化成了图形的搜寻，我们只要把解答给「找出来」就行了。</p>
  <p>图形搜寻的方法大致可以分为「深度优先搜寻 (Depth-First Search, DFS)、广度优先搜寻 (Breath-First Search, BFS)、最佳优先搜寻 (Best-First Search, BestFS) 等三类。</p>
  <p>然后针对最佳优先搜寻的部份，还有一种具有理论背景，且较为强大好用的 A* 搜寻法可採用。</p>
  <h3 id="图形的表达"><a href="#图形的表达">图形的表达</a></h3>
  <p>图形是由节点 (node) 与连线 (edge) 所组成的。举例而言，以下是一个包含六个节点与十条连线的简单图形。</p>
  <div class="figure">
    <img src="../img/graphSearch.jpg" alt="图、图形 Graph 的范例" /><p class="caption">图、图形 Graph 的范例</p>
  </div>
  <h3 id="深度优先搜寻"><a href="#深度优先搜寻">深度优先搜寻</a></h3>
  <p>所谓的「深度优先搜寻」 (Depth-First Search, DFS)，就是一直往尚未访问过的第一个邻居节点走去的一种方法，这种方法可以採用程式设计中的「递迴技巧」完成，以下是深度搜寻的演算法：</p>
<pre><code>Algorithm DFS(graph, node) {  // 深度优先搜寻，graph : 图形, node:节点
  if (node.visited) return;     // 如果已访问过，就不再访问
  node.visited = 1;             //   并设定为已访问
  foreach (neighbor of node)  // 对於每个邻居
  DFS(graph, neighbor);     //   逐一进行深度优先搜寻的访问。
  end</code></pre>
  <p>您可以看到上述的演算法中，我们单纯採用递迴的方式，就可以轻易的完成整个 DFS 演算法。</p>
  <p>当然、实作为程式的时候，会稍微复杂一点，以下是使用 Javascript 的实作方式：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度优先搜寻</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已访问过，就不再访问</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否则、印出节点</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   并设定为已访问</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出邻居节点</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 对於每个邻居</span>
  <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一进行访问</span>
  }
  }</code></pre>
  <p>针对上述的范例图形，若採用深度优先搜寻，其结果可能如下所示 (图中红色的数字代表访问顺序)</p>
  <div class="figure">
    <img src="../img/dfs.jpg" alt="图、深度优先搜寻的顺序" /><p class="caption">图、深度优先搜寻的顺序</p>
  </div>
  <h3 id="广度优先搜寻"><a href="#广度优先搜寻">广度优先搜寻</a></h3>
  <p>虽然深度优先搜寻可以搜寻整个图形，但是却很可能绕了很久才找到目标，於是从起点到目标可能会花费很久的时间 (或说路径长度过长)。</p>
  <p>如果我们想找出到达目标最少的步骤，那麼就可以採用「广度优先搜寻」 (Breath-First Search, BFS) 的方式。</p>
  <p>广度优先搜寻 BFS 是从一个节点开始，将每个邻居节点都一层一层的拜访下去，深度最浅的节点会优先被拜访的方式。</p>
  <p>举例而言，针对上述的图形范例，若採用「广度优先搜寻 BFS 」的方式，那麼拜访顺序将会如下所示：</p>
  <div class="figure">
    <img src="../img/bfs.jpg" alt="图、广度优先搜寻的顺序" /><p class="caption">图、广度优先搜寻的顺序</p>
  </div>
  <p>要能用程式进行广度优先搜寻，必须採用「先进先出」(First-in First-Out, FIFO) 的方式管理节点，因此通常在「广度优先搜寻」里会有个佇列 (queue) 结构，以下是 BFS 的演算法：</p>
<pre><code>Algorithm BFS(graph, queue)
  if queue.empty() return;
  node = queue.dequeue();
  if (!node.visited)
  node.visited = true
  else
  return;
  foreach (neighbor of node)
  if (!neighbor.visited)
  queue.push(neighbor)
  end</code></pre>
  <p>以下是使用 Javascript 的 BFS 程式实作片段：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 广度优先搜寻</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，则返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否则、取出 queue 的第一个节点。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果该节点尚未拜访过。</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   标示为已拜访</span>
  <span class="kw">else</span>                       <span class="co">// 否则 (已访问过)</span>
  <span class="kw">return</span>;                  <span class="co">//   不继续搜寻，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出节点</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出邻居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 对於每个邻居</span>
  <span class="kw">var</span> n = neighbors[i];
  <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如该邻居还没被拜访过</span>
  <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
  }</code></pre>
  <h3 id="最佳优先搜寻"><a href="#最佳优先搜寻">最佳优先搜寻</a></h3>
  <p>但是、上述两个方法其实都还不够好，深度搜寻会猛冲乱冲，而广度搜寻则会耗费太多的记忆体，并且没有效率，无法很快的找到目标点。</p>
  <p>假如我们能够知道哪些点距离目标点最近，也就是哪些点比较好的话，那就能採用「最佳优先搜寻 (Best-First Search) 的方式来搜寻了。</p>
  <p>最佳优先搜寻的实作方法与广度优先搜寻类似，但是并不採用佇列 (queue) ，而是採用一种根据优先程度排序的结构，每次都取出最好的那个继续进行搜寻。</p>
  <p>但是、节点的好坏通常很难评估，单纯採用某种距离去评估往往会过度简化问题，这点往往是最佳优先搜寻的困难之所在。</p>
  <p>还好、有时我们不需要非常精确的评估，只要问题符合 <img src="../timg/9c5e6fefcb1f.jpg" /> 这样的单调 (monotone) 特性，就可以使用 <code>A*</code> 演算法来进行较快速的搜寻，这种方法比广度优先搜寻通常快很多，因为 <code>A*</code> 不会搜寻所有节点，而是有系统的朝著整体较好的方向前进，这种方法在电脑游戏 (Game) 上常被用在 NPC (非人类角色) 的智慧型搜寻行为设计上面，是人工智慧搜寻方法中较强大的一种。</p>
  <h3 id="参考文献-7"><a href="#参考文献-7">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/A*_search_algorithm">Wikipedia:A* search algorithm</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%AF%BB%E7%AE%97%E6%B3%95">维基百科:A*搜寻演算法</a></li>
    <li><a href="http://zh.wikipedia.org/zh-tw/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">维基百科:广度优先搜索</a></li>
    <li><a href="http://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">维基百科:深度优先搜索</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作深度与广度搜寻法"><a href="#实作深度与广度搜寻法">实作：深度与广度搜寻法</a></h2>
  <h3 id="简介-3"><a href="#简介-3">简介</a></h3>
  <p>为了进一步理解深度优先搜寻 (Depth-First Search) 与广度优先搜寻 (Breath-First Search) ，我们将在本文中採用 JavaScript 实作这两个图形搜寻算法，并且在 node.js 平台上进行测试。</p>
  <p>在以下程式中，变数 g 代表下列图形，而程式中的 dfs() 函数代表深度优先搜寻算法，bfs() 函数代表广度优先搜寻算法。</p>
  <div class="figure">
    <img src="../img/graphSearch.jpg" alt="图、图形 Graph 的范例" /><p class="caption">图、图形 Graph 的范例</p>
  </div>
  <h3 id="程式实作"><a href="#程式实作">程式实作</a></h3>
  <p>档案：graphSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);

  <span class="kw">var</span> printf = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">process</span>.<span class="ot">stdout</span>.<span class="fu">write</span>(<span class="ot">util</span>.<span class="ot">format</span>.<span class="fu">apply</span>(<span class="kw">null</span>, arguments));
  }

  <span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
  <span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }

  <span class="kw">var</span> g = {            <span class="co">// graph: 被搜寻的网路</span>
  <span class="dv">1</span>: {<span class="dt">n</span>:[<span class="dv">2</span>,<span class="dv">5</span>], <span class="dt">v</span>:<span class="dv">0</span>}, <span class="co">// n: neighbor (邻居), v: visited (是否被访问过)</span>
  <span class="dv">2</span>: {<span class="dt">n</span>:[<span class="dv">3</span>,<span class="dv">4</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">3</span>: {<span class="dt">n</span>:[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">4</span>: {<span class="dt">n</span>:[<span class="dv">5</span>,<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">5</span>: {<span class="dt">n</span>:[<span class="dv">6</span>], <span class="dt">v</span>:<span class="dv">0</span>},
  <span class="dv">6</span>: {<span class="dt">n</span>:[], <span class="dt">v</span>:<span class="dv">0</span>}
  };

  <span class="kw">function</span> <span class="fu">init</span>(g) { <span class="co">// 初始化、设定 visited 为 0</span>
  <span class="kw">for</span> (i <span class="kw">in</span> g) g[i].<span class="fu">v</span> = <span class="dv">0</span>;
  }

  <span class="kw">function</span> <span class="fu">dfs</span>(g, node) { <span class="co">// 深度优先搜寻</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> !=<span class="dv">0</span>) <span class="kw">return</span>;   <span class="co">// 如果已访问过，就不再访问</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);       <span class="co">// 否则、印出节点</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;              <span class="co">//   并设定为已访问</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>;  <span class="co">// 取出邻居节点</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) {  <span class="co">// 对於每个邻居</span>
  <span class="fu">dfs</span>(g, neighbors[i]);     <span class="co">//   逐一进行访问</span>
  }
  }

  <span class="kw">var</span> queue=[<span class="dv">1</span>];            <span class="co">// BFS 用的 queue, 起始点为 1。</span>

  <span class="kw">function</span> <span class="fu">bfs</span>(g, q) { <span class="co">// 广度优先搜寻</span>
  <span class="kw">if</span> (<span class="ot">q</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">return</span>; <span class="co">// 如果 queue 已空，则返回。</span>
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否则、取出 queue 的第一个节点。</span>
  <span class="kw">if</span> (g[node].<span class="fu">v</span> == <span class="dv">0</span>)        <span class="co">// 如果该节点尚未拜访过。</span>
  g[node].<span class="fu">v</span> = <span class="dv">1</span>;           <span class="co">//   标示为已拜访</span>
  <span class="kw">else</span>                       <span class="co">// 否则 (已访问过)</span>
  <span class="kw">return</span>;                  <span class="co">//   不继续搜寻，直接返回。</span>
  <span class="fu">printf</span>(<span class="st">&quot;%d=&gt;&quot;</span>, node);      <span class="co">// 印出节点</span>
  <span class="kw">var</span> neighbors = g[node].<span class="fu">n</span>; <span class="co">// 取出邻居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 对於每个邻居</span>
  <span class="kw">var</span> n = neighbors[i];
  <span class="kw">if</span> (!g[n].<span class="fu">visited</span>)       <span class="co">// 假如该邻居还没被拜访过</span>
  <span class="ot">q</span>.<span class="fu">push</span>(n);             <span class="co">//   就放入 queue 中</span>
  }
  <span class="fu">bfs</span>(g, q);
  }

  <span class="fu">printf</span>(<span class="st">&quot;dfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">dfs</span>(g, <span class="dv">1</span>); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);     <span class="co">// 呼叫深度优先搜寻。</span>
  <span class="fu">printf</span>(<span class="st">&quot;bfs:&quot;</span>); <span class="fu">init</span>(g); <span class="fu">bfs</span>(g, queue); <span class="fu">printf</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); <span class="co">// 呼叫广度优先搜寻。</span></code></pre>
  <h3 id="执行结果-1"><a href="#执行结果-1">执行结果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node graphSearch.js
  dfs:1=&gt;2=&gt;3=&gt;4=&gt;5=&gt;6=&gt;
  bfs:1=&gt;2=&gt;5=&gt;3=&gt;4=&gt;6=&gt;</code></pre>
  <h3 id="结语-5"><a href="#结语-5">结语</a></h3>
  <p>从以上范例您可以看到 BFS 与 DFS 之差异，不过我们没有为节点加入好坏的评估函数，因此没有实作最佳优先搜寻，或许读者可以自行尝试修改看看。</p>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作以深度优先搜寻解决老鼠走迷宫问题"><a href="#实作以深度优先搜寻解决老鼠走迷宫问题">实作：以深度优先搜寻解决老鼠走迷宫问题</a></h2>
  <h3 id="前言-3"><a href="#前言-3">前言</a></h3>
  <p>虽然深度优先搜寻 (DFS) 与广度优先搜寻 (BFS) 等演算法通常是用在「图形」这种结构上的，不过「图形」的结构倒是不一定要真实且完整的表达出来，在很多人工智慧的问题上，我们不会看到完整的「图形结构」，只会看到某个节点有哪些邻居节点，然后就可以用 BFS 与 DFS 进行搜寻了。</p>
  <p>老鼠走迷宫问题，就是一个可以採用图形搜寻来解决的经典问题，其中每个节点的邻居，就是上下左右四个方向，只要没有被墙给挡住，就可以走到邻居节点去，因此我们可以採用图形搜寻的方法来解决迷宫问题，以下是我们的程式实作。</p>
  <h3 id="程式实作老鼠走迷宫"><a href="#程式实作老鼠走迷宫">程式实作：老鼠走迷宫</a></h3>
  <p>档案：pathFinder.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="kw">function</span> <span class="fu">matrixPrint</span>(m) {
  <span class="kw">for</span>(<span class="kw">var</span> i=<span class="dv">0</span>;i&lt;<span class="ot">m</span>.<span class="fu">length</span>;i++)
  <span class="fu">log</span>(m[i]);
  }

  <span class="kw">function</span> <span class="fu">strset</span>(s, i, c) {
  <span class="kw">return</span> <span class="ot">s</span>.<span class="fu">substr</span>(<span class="dv">0</span>, i) + c + <span class="ot">s</span>.<span class="fu">substr</span>(i<span class="dv">+1</span>);
  }

  <span class="kw">function</span> <span class="fu">findPath</span>(m, x, y) {
  <span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
  <span class="fu">log</span>(<span class="st">&quot;x=&quot;</span>+x+<span class="st">&quot; y=&quot;</span>+y);
  <span class="fu">matrixPrint</span>(m);
  <span class="kw">if</span> (x&gt;=<span class="dv">6</span>||y&gt;=<span class="dv">8</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;*&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;+&#39;</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39; &#39;</span>) m[x] = <span class="fu">strset</span>(m[x], y, <span class="st">&#39;.&#39;</span>);
  <span class="kw">if</span> (m[x][y] == <span class="st">&#39;.&#39;</span> &amp;&amp; (x == <span class="dv">5</span> || y==<span class="dv">7</span>))
  <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span> (y&lt;<span class="dv">7</span>&amp;&amp;m[x][y<span class="dv">+1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向右</span>
  <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">+1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&lt;<span class="dv">5</span>&amp;&amp;m[x<span class="dv">+1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向下</span>
  <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">+1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(y&gt;<span class="dv">0</span>&amp;&amp;m[x][y<span class="dv">-1</span>]==<span class="st">&#39; &#39;</span>) <span class="co">//向左</span>
  <span class="kw">if</span> (<span class="fu">findPath</span>(m, x,y<span class="dv">-1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span>(x&gt;<span class="dv">0</span>&amp;&amp;m[x<span class="dv">-1</span>][y]==<span class="st">&#39; &#39;</span>) <span class="co">//向上</span>
  <span class="kw">if</span> (<span class="fu">findPath</span>(m, x<span class="dv">-1</span>,y)) <span class="kw">return</span> <span class="kw">true</span>;
  m[x][y]=<span class="st">&#39;+&#39;</span>;
  <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="kw">var</span> m =[<span class="st">&quot;********&quot;</span>,
  <span class="st">&quot;** * ***&quot;</span>,
  <span class="st">&quot;     ***&quot;</span>,
  <span class="st">&quot;* ******&quot;</span>,
  <span class="st">&quot;*     **&quot;</span>,
  <span class="st">&quot;***** **&quot;</span>];

  <span class="fu">findPath</span>(m, <span class="dv">2</span>, <span class="dv">0</span>);
  <span class="fu">log</span>(<span class="st">&quot;=========================&quot;</span>);
  <span class="fu">matrixPrint</span>(m);</code></pre>
  <h3 id="执行结果-2"><a href="#执行结果-2">执行结果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node pathFinder.js
  =========================
  x=2 y=0
  ********
  ** * ***
  ***
  * ******
  *     **
  ***** **
  =========================
  x=2 y=1
  ********
  ** * ***
  .    ***
  * ******
  *     **
  ***** **
  =========================
  x=2 y=2
  ********
  ** * ***
  ..   ***
  * ******
  *     **
  ***** **
  =========================
  x=2 y=3
  ********
  ** * ***
  ...  ***
  * ******
  *     **
  ***** **
  =========================
  x=2 y=4
  ********
  ** * ***
  .... ***
  * ******
  *     **
  ***** **
  =========================
  x=1 y=4
  ********
  ** * ***
  .....***
  * ******
  *     **
  ***** **
  =========================
  x=1 y=2
  ********
  ** *.***
  .....***
  * ******
  *     **
  ***** **
  =========================
  x=3 y=1
  ********
  **.*.***
  .....***
  * ******
  *     **
  ***** **
  =========================
  x=4 y=1
  ********
  **.*.***
  .....***
  *.******
  *     **
  ***** **
  =========================
  x=4 y=2
  ********
  **.*.***
  .....***
  *.******
  *.    **
  ***** **
  =========================
  x=4 y=3
  ********
  **.*.***
  .....***
  *.******
  *..   **
  ***** **
  =========================
  x=4 y=4
  ********
  **.*.***
  .....***
  *.******
  *...  **
  ***** **
  =========================
  x=4 y=5
  ********
  **.*.***
  .....***
  *.******
  *.... **
  ***** **
  =========================
  x=5 y=5
  ********
  **.*.***
  .....***
  *.******
  *.....**
  ***** **
  =========================
  ********
  **.*.***
  .....***
  *.******
  *.....**
  *****.**</code></pre>
  <h3 id="结语-6"><a href="#结语-6">结语</a></h3>
  <p>在上面的输出结果中，<code>*</code> 代表该位置是墙壁，而空格则代表是可以走的路，老鼠走过的地方会放下一个 <code>.</code> 符号，於是您可以看到在上述程式的输出中，老鼠最后走出了迷宫，完成了任务。</p>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作以广度优先搜寻解决拼图问题"><a href="#实作以广度优先搜寻解决拼图问题">实作：以广度优先搜寻解决拼图问题</a></h2>
  <h3 id="前言-4"><a href="#前言-4">前言</a></h3>
  <p>以下的「拼图问题」是将一个已经移动打乱过的拼盘，想办法移动回原本样子的问题。</p>
  <div class="figure">
    <img src="../img/puzzle.jpg" alt="图、本文程式中的拼图问题" /><p class="caption">图、本文程式中的拼图问题</p>
  </div>
  <p>在以下程式中，我们用一个 3*3 的阵列来代表拼盘，并且用数字 0 来代表其中的空格，因此将方块 2 移动到空格，其实是用将 0 与 2 两个数字位置交换所达成的。</p>
  <p>透过这样的资料结构，我们就可以用「广度优先搜寻」(BFS) 来解决拼图问题了，以下是我们用 JavaScript 实作，并用 node.js 进行测试的结果。</p>
  <h3 id="程式实作拼图问题"><a href="#程式实作拼图问题">程式实作：拼图问题</a></h3>
  <p>档案：puzzleSearch.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;
  <span class="kw">var</span> up = <span class="dv">1</span>, right=<span class="dv">2</span>, down=<span class="dv">3</span>, left=<span class="dv">4</span>;

  <span class="kw">function</span> <span class="fu">enqueue</span>(a, o) { <span class="ot">a</span>.<span class="fu">push</span>(o); }
  <span class="kw">function</span> <span class="fu">dequeue</span>(a) { <span class="kw">return</span> <span class="ot">a</span>.<span class="fu">shift</span>(); }
  <span class="kw">function</span> <span class="fu">equal</span>(a, b) { <span class="kw">return</span> <span class="ot">JSON</span>.<span class="fu">stringify</span>(a)===<span class="ot">JSON</span>.<span class="fu">stringify</span>(b); }
  <span class="kw">function</span> <span class="fu">board2str</span>(b) { <span class="kw">return</span> <span class="ot">b</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>); }

  <span class="kw">function</span> <span class="fu">findXY</span>(board, value) {
  <span class="kw">for</span> (<span class="kw">var</span> x=<span class="dv">0</span>; x&lt;<span class="ot">board</span>.<span class="fu">length</span>; x++)
  <span class="kw">for</span> (<span class="kw">var</span> y=<span class="dv">0</span>; y&lt;board[x].<span class="fu">length</span>; y++)
  <span class="kw">if</span> (board[x][y] === value)
  <span class="kw">return</span> {<span class="dt">x</span>:x,<span class="dt">y</span>:y};
  <span class="kw">return</span> <span class="kw">null</span>;
  }

  <span class="kw">function</span> <span class="fu">boardClone</span>(b) {
  <span class="kw">var</span> nb = [];
  <span class="kw">for</span> (<span class="kw">var</span> x <span class="kw">in</span> b)
  nb[x] = b[x].<span class="fu">slice</span>(<span class="dv">0</span>);
  <span class="kw">return</span> nb;
  }

  <span class="kw">function</span> <span class="fu">swap</span>(b,x1,y1,x2,y2) {
  x2 = <span class="ot">Math</span>.<span class="fu">round</span>(x2), y2=<span class="ot">Math</span>.<span class="fu">round</span>(y2);
  <span class="kw">if</span> (x2&lt;<span class="dv">0</span> || x2 &gt; <span class="dv">2</span> || y2&lt;<span class="dv">0</span> || y2&gt;<span class="dv">2</span>)
  <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> t = b[x1][y1];
  b[x1][y1]=b[x2][y2];
  b[x2][y2]=t;
  <span class="kw">return</span> <span class="kw">true</span>;
  }

  <span class="kw">function</span> <span class="fu">move</span>(board, dir) {
  <span class="kw">var</span> xy = <span class="fu">findXY</span>(board, <span class="dv">0</span>);
  <span class="kw">var</span> x = <span class="ot">xy</span>.<span class="fu">x</span>, y=<span class="ot">xy</span>.<span class="fu">y</span>;
  <span class="kw">var</span> nboard = <span class="fu">boardClone</span>(board);
  <span class="kw">var</span> s = <span class="kw">false</span>;
  <span class="kw">switch</span> (dir) {
  <span class="kw">case</span> <span class="dt">up</span>:    s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">-1</span>,y); <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dt">right</span>: s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">+1</span>); <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dt">down</span>:  s=<span class="fu">swap</span>(nboard,x,y,x<span class="dv">+1</span>,y); <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dt">left</span>:  s=<span class="fu">swap</span>(nboard,x,y,x,y<span class="dv">-1</span>); <span class="kw">break</span>;
  }
  <span class="kw">if</span> (s)
  <span class="kw">return</span> nboard;
  <span class="kw">else</span>
  <span class="kw">return</span> <span class="kw">null</span>;
  }

  <span class="kw">function</span> <span class="fu">moveAdd</span>(board, dir, neighbors) {
  <span class="kw">var</span> nboard = <span class="fu">move</span>(board, dir);
  <span class="kw">if</span> (nboard !== <span class="kw">null</span>) {
  <span class="ot">neighbors</span>.<span class="fu">push</span>(nboard);
  }
  }

  <span class="kw">function</span> <span class="fu">getNeighbors</span>(board) {
  <span class="kw">var</span> neighbors = [];
  <span class="fu">moveAdd</span>(board, up,    neighbors);
  <span class="fu">moveAdd</span>(board, down,  neighbors);
  <span class="fu">moveAdd</span>(board, right, neighbors);
  <span class="fu">moveAdd</span>(board, left,  neighbors);
  <span class="kw">return</span> neighbors;
  }

  <span class="kw">var</span> goal = [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],
  [<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">4</span>],
  [<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>]];

  <span class="kw">var</span> start= [[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>],
  [<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>],
  [<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">6</span>]];

  <span class="kw">var</span> queue=[start];            <span class="co">// BFS 用的 queue, 起始点为 1。</span>
  <span class="kw">var</span> visited={};
  <span class="kw">var</span> parent={};
  <span class="kw">var</span> level={};

  <span class="kw">function</span> <span class="fu">bfs</span>(q, goal) { <span class="co">// 广度优先搜寻</span>
  <span class="kw">while</span> (<span class="ot">q</span>.<span class="fu">length</span> &gt; <span class="dv">0</span>) {
  <span class="kw">var</span> node = <span class="fu">dequeue</span>(q);     <span class="co">// 否则、取出 queue 的第一个节点。</span>
  <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(node);
  <span class="co">//  log(&quot;q.length=%d level=%d\n===node===\n%s==parent==\n%s&quot;, q.length, level[nodestr], nodestr, parent[nodestr]); // 印出节点</span>
  <span class="kw">if</span> (<span class="fu">equal</span>(node, goal)) <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">if</span> (visited[nodestr]===<span class="kw">undefined</span>)        <span class="co">// 如果该节点尚未拜访过。</span>
  visited[nodestr] = <span class="kw">true</span>; <span class="co">//   标示为已拜访</span>
  <span class="kw">else</span>                       <span class="co">// 否则 (已访问过)</span>
  <span class="kw">continue</span>;                <span class="co">//   不继续搜寻，直接返回。</span>
  <span class="kw">var</span> neighbors = <span class="fu">getNeighbors</span>(node); <span class="co">// 取出邻居。</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> neighbors) { <span class="co">// 对於每个邻居</span>
  <span class="kw">var</span> n = neighbors[i];
  <span class="kw">var</span> nstr = <span class="fu">board2str</span>(n);
  <span class="kw">if</span> (!visited[nstr]) {    <span class="co">// 假如该邻居还没被拜访过</span>
  parent[nstr] = nodestr;
  level[nstr] = level[nodestr] + <span class="dv">1</span>;
  <span class="fu">enqueue</span>(q, n);         <span class="co">//   就放入 queue 中</span>
  }
  }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="kw">function</span> <span class="fu">backtrace</span>(goal) {
  <span class="fu">log</span>(<span class="st">&quot;======= backtrace =========&quot;</span>);
  <span class="kw">var</span> nodestr = <span class="fu">board2str</span>(goal);
  <span class="kw">while</span> (nodestr !== <span class="kw">undefined</span>) {
  <span class="fu">log</span>(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, nodestr);
  nodestr = parent[nodestr];
  }
  }

  level[<span class="fu">board2str</span>(start)]=<span class="dv">0</span>;
  <span class="kw">var</span> found = <span class="fu">bfs</span>(queue, goal); <span class="co">// 呼叫广度优先搜寻。</span>
  <span class="fu">log</span>(<span class="st">&quot;bfs:found=%s&quot;</span>, found);
  <span class="kw">if</span> (found)
  <span class="fu">backtrace</span>(goal);</code></pre>
  <h3 id="执行结果-3"><a href="#执行结果-3">执行结果</a></h3>
<pre><code>D:\Dropbox\Public\web\ai\code\search&gt;node puzzleSearch.js
  bfs:found=true
  ======= backtrace =========
  1,2,3
  8,0,4
  7,6,5

  1,0,3
  8,2,4
  7,6,5

  1,3,0
  8,2,4
  7,6,5

  1,3,4
  8,2,0
  7,6,5

  1,3,4
  8,2,5
  7,6,0

  1,3,4
  8,2,5
  7,0,6</code></pre>
  <h3 id="结语-7"><a href="#结语-7">结语</a></h3>
  <p>在上述执行结果中，我们是将盘面拼完后，才逆向追踪印出移动过程，因此整个移动方法应该从最下面的盘面看起。换句话说，真正的顺序如下：</p>
<pre><code>1,3,4    1,3,4    1,3,4     1,3,0    1,0,3    1,2,3
  8,2,5 =&gt; 8,2,5 =&gt; 8,2,0 =&gt;  8,2,4 =&gt; 8,2,4 =&gt; 8,0,4
  7,0,6    7,6,0    7,6,5     7,6,5    7,6,5    7,6,5</code></pre>
  <p>从上面过程中，您可以看出我们的程式将打乱的盘面给拼回来了。</p>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h1 id="电脑下棋"><a href="#电脑下棋">电脑下棋</a></h1>
  <p>自从有了电脑之后，人们就一直想让电脑「学会」下棋的能力。事实上、远在 1952 年，那时的电脑虽然还不具备下棋的能力，但是资讯领域的理论派大师图灵 (Alan Turing) 就已经在构思如何写「电脑下棋」的程式了，以下是节录自维基百科的一段描述：</p>
  <blockquote>
    <p>1952年，图灵写了一个西洋棋程式。可是，当时没有一台电脑有足够的运算能力去执行这个程式，他就模仿电脑，每走一步要用半小时。他与一位同事下了一盘，结果程式输了。</p>
    <p>后来美国新墨西哥州洛斯阿拉莫斯国家实验室的研究群根据图灵的理论，在ENIAC上设计出世界上第一个电脑程式的象棋－洛斯阿拉莫斯象棋。</p>
  </blockquote>
  <p>世界上有很多种棋类游戏，对於台湾人而言，最常下的几种棋类，大至上包含「围棋、象棋、五子棋、西洋棋」等等。</p>
  <p>围棋的英文名称为 GO，起源於中国，推测起源时间为大约公元前6世纪。传说尧的儿子丹朱顽劣，尧发明围棋以教育丹朱，陶冶其性情。目前围棋的最早可靠记载见於春秋时期的《左传》，战国时期的弈秋是见於史籍的第一位棋手，最早的围棋文物可以追溯到战国时期。汉朝时棋盘为17路，南北朝时候，棋盘定型为现在的19道棋盘，传入朝鲜半岛，并且出现了评定棋手水平的围棋九品制。围棋逐渐成为中国古代知识阶层修身养性的一项必修课目，为「琴棋书画」四艺之一。</p>
  <p>围棋在公元7世纪传入日本，很快就流行於宫廷和贵族之中。战国末期，丰臣秀吉设立棋所。德川幕府时代，出现了在天皇或将军面前对弈的「御城棋」，日本围棋逐渐兴盛，出现了本因坊、安井、井上、林等围棋世家。其中坊门尤其人才辈出，先后出现了道策、丈和、秀和、秀策、秀甫、秀荣等杰出棋士。日本围棋由於废除了中国古代围棋的座子制（古代中国围棋是放四个座子，就是两黑两白放在对角星的位置上，双方在这个基础上开始布局），布局理论得以极大发展。</p>
  <p>明治维新以后，棋手失去幕府支援，开始谋求新的谋生手段，导致了新闻棋战和现代段位制的出现，并创立了全国性的日本棋院。昭和时代，吴清源和木谷实共同掀起了「新布局」的潮流，开始了现代围棋的时代。其后日本棋界一流棋手辈出，如坂田荣男，藤泽秀行，高川格，及后来的大竹英雄，武宫正树，小林光一，石田芳夫等。</p>
  <div class="figure">
    <img src="../img/ChineseChess.jpg" />
  </div>
  <p>五子棋的英文名称为 GOMOKU，在日本平安时代就有，是日本人颇受欢迎的棋类。自1899年日本棋士黒岩涙香证明了原始规则的五子棋先下必胜后，五子棋迈入一条不断改良的道路，经过数十年的修改、验证、再修改，最终发展出加入禁手的五子棋，并经过公开徵名，称为连珠（RENJU），因此规则在日本成型，又称为日式规则或连珠规则。</p>
  <p>西洋棋的英文就是 chess，又称欧洲象棋或国际象棋，一般被认为源自一种印度的游戏——恰图兰卡，7世纪时流传至波斯成为波斯象棋。穆斯林统治波斯后，它被带到伊斯兰的国家。九世纪传入南欧，10世纪时传到西班牙，11世纪传到英国。15世纪末，现代西洋棋的规则逐渐成形。现代的玩法与19世纪时的大致相同。由於流传已久，因此在各地与各时期產生不少的西洋棋变体规则。</p>
  <div class="figure">
    <img src="../img/EuropeanChess.jpg" />
  </div>
  <p>相信大部分的人对以上棋类都相当熟悉，也都知晓这些棋类的游戏规则了，现在、就让我们大致介绍一下如何撰写「电脑下棋」的程式好了。</p>
  <p>要写下棋程式，大致有三个关键技巧，第一个是盘面的表达，第二个是评估函数，第三个是搜寻技巧。</p>
  <ul>
    <li>盘面表达：通常我们可以用一个阵列代表盘面。举例而言、在支援 Unicode 的系统中，我们可以用字元阵列代表棋盘，对於围棋或五子棋而言，我们可以用 O 代表白子、 X 代表黑子，然后用空白字元代表该位置还没有任何子。同样的、我们可以用中文字的「将士象车马砲卒」与「帅仕相俥傌炮兵」来代表象棋的子，对於西洋棋也可以如法炮製，只要对每个棋子都取一个中文名字或代号就行了。</li>
    <li>评估函数：接著我们可以写一个函数来评估某个盘面的分数，举例而言、对於五子棋而言，我方连五子得 100 分，对方连五子则扣 100 分，我方连四子得 30 分，对方连四子则扣 30 分， ......，我方连两子得 2 分，对方连两子则扣两分。而对象棋而言，则可以对每一子的重要性计分，例如将算 100 分，车算 50 分，砲算 30 分等等。</li>
    <li>搜寻策略：对於比较复杂的棋类，我们通常需要事先设想后面好几步的情况，能够想得越周全且越远的人，通常就会越厉害。电脑下棋也是如此，由於现在电脑的速度非常快，因此往往可以利用 Min-Max 演算法搜寻两三层，甚至到五六层。而且、只要加上 Alpha-Beta Cut 修剪法，有时甚至可以搜寻到十几层，这样的能力往往可以超过人类，因此现在电脑在「象棋、西洋棋、五子棋」上的棋力通常很强，即使职业的棋手也未必能够打赢电脑。(不过围棋目前还是人类较强，电脑还没办法下赢职业棋手)。</li>
  </ul>
  <p>在 1997 年的时候，IBM 曾经用他的「深蓝」(Deep Blue) 电脑与当时的世界西洋棋王「卡斯巴罗夫」公开对战，结果「卡斯巴罗夫」在第一盘胜利之后，却连续输了两盘，於是败给了「深蓝电脑」。虽然这场棋赛引起了一些争议，但是电脑在西洋棋上的棋力，应该已经确定不亚於职业棋手，甚至是有过之而无不及了。</p>
  <p>我们将在以下的几篇文章中，进一步讨论电脑下棋的方法，并且实作出一个「五子棋」的「电脑自动下棋」程式。</p>
  <h3 id="参考文献-8"><a href="#参考文献-8">参考文献</a></h3>
  <ul>
    <li>Wikipedia:<a href="http://en.wikipedia.org/wiki/Computer_chess">Computer chess</a></li>
    <li>维基百科:<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E8%B1%A1%E6%A3%8B">电脑象棋</a></li>
    <li>Wikipedia:<a href="http://en.wikipedia.org/wiki/Deep_Blue_(chess_computer)">Deep Blue</a></li>
    <li>维基百科:<a href="http://zh.wikipedia.org/wiki/%E6%B7%B1%E8%97%8D_(%E9%9B%BB%E8%85%A6)">深蓝</a></li>
    <li>维基百科:<a href="http://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E8%B1%A1%E6%A3%8B">西洋棋</a></li>
    <li>维基百科:<a href="http://zh.wikipedia.org/zh-tw/%E5%9B%B4%E6%A3%8B">围棋</a></li>
    <li><a href="http://chessprogramming.wikispaces.com/Learning">http://chessprogramming.wikispaces.com/Learning</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h2 id="实作五子棋程式"><a href="#实作五子棋程式">实作：五子棋程式</a></h2>
  <h3 id="简介-4"><a href="#简介-4">简介</a></h3>
  <p>在本文中，我们设计了一个完全只是依赖「盘面评估函数」的五子棋程式，这个程式并没有採用「Min-Max 对局搜寻法」，更没有採用「Alpha-Beta 修剪法」，但是已经能够与一般人对战，有时候还可以赢得棋局。</p>
  <p>以下是这个程式执行的一个画面，我们採用命令列的设计方式，使用者下子时必须输入格子的座标，该座标由两个 16 进位字母组成，例如图中的 62 代表下在第六列第二行的位置。</p>
  <div class="figure">
    <img src="../img/chess.jpg" alt="图、五子棋程式的一个对局画面" /><p class="caption">图、五子棋程式的一个对局画面</p>
  </div>
  <h3 id="程式实作-1"><a href="#程式实作-1">程式实作</a></h3>
  <p>整个程式的实作只包含以下这个 chess.js 档案，完整原始码如下。</p>
  <p>档案：chess.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// 五子棋游戏，单机命令列版</span>
  <span class="co">//   人对人下：node chess P2P</span>
  <span class="co">//   人对电脑：node chess P2C</span>
  <span class="co">// 作者：陈钟诚</span>
  <span class="kw">var</span> util = <span class="fu">require</span>(<span class="st">&quot;util&quot;</span>);
  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;
  <span class="kw">var</span> r = <span class="fu">require</span>(<span class="st">&#39;readline&#39;</span>).<span class="fu">createInterface</span>(<span class="ot">process</span>.<span class="fu">stdin</span>, <span class="ot">process</span>.<span class="fu">stdout</span>);

  <span class="co">// 印出讯息，并取得输入。</span>
  <span class="kw">var</span> prompt = <span class="kw">function</span>(turn) {
  <span class="kw">var</span> msg = <span class="fu">format</span>(<span class="st">&#39;将 %s 下在 :    &#39;</span>, turn);
  <span class="ot">r</span>.<span class="fu">setPrompt</span>(msg);
  <span class="ot">r</span>.<span class="fu">prompt</span>();
  }

  <span class="kw">var</span> format = <span class="kw">function</span>() { <span class="co">// 字串格式化 </span>
  <span class="kw">return</span> <span class="ot">util</span>.<span class="ot">format</span>.<span class="fu">apply</span>(<span class="kw">null</span>, arguments);
  }

  <span class="co">// 棋盘物件</span>
  <span class="kw">var</span> Board = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">m</span> = [];
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
  <span class="kw">this</span>.<span class="fu">m</span>[r] = [];
  <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;<span class="dv">16</span>; c++)
  <span class="kw">this</span>.<span class="fu">m</span>[r][c] = <span class="st">&#39;-&#39;</span>;
  }
  }

  <span class="co">// 将棋盘格式化成字串</span>
  <span class="ot">Board</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> str = <span class="st">&quot;  0 1 2 3 4 5 6 7 8 9 a b c d e f</span><span class="ch">\n</span><span class="st">&quot;</span>;
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
  str += <span class="ot">r</span>.<span class="fu">toString</span>(<span class="dv">16</span>)+<span class="st">&quot; &quot;</span>+<span class="kw">this</span>.<span class="fu">m</span>[r].<span class="fu">join</span>(<span class="st">&quot; &quot;</span>)+<span class="st">&quot; &quot;</span>+<span class="ot">r</span>.<span class="fu">toString</span>(<span class="dv">16</span>)+<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
  }
  str += <span class="st">&quot;  0 1 2 3 4 5 6 7 8 9 a b c d e f</span><span class="ch">\n</span><span class="st">&quot;</span>;
  <span class="kw">return</span> str;
  }

  <span class="co">// 显示棋盘</span>
  <span class="ot">Board</span>.<span class="ot">prototype</span>.<span class="fu">show</span> = <span class="kw">function</span>() {
  <span class="fu">log</span>(<span class="kw">this</span>.<span class="fu">toString</span>());
  }

  <span class="co">// 以下为游戏相关资料与函数</span>
  <span class="co">// var zero = [ 0, 0, 0, 0, 0];</span>
  <span class="co">// var inc  = [-2,-1, 0, 1, 2];</span>
  <span class="co">// var dec  = [ 2, 1, 0,-1,-2];</span>
  <span class="kw">var</span> z9   = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>];
  <span class="kw">var</span> i9   = [-<span class="dv">4</span>,-<span class="dv">3</span>,-<span class="dv">2</span>,-<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
  <span class="kw">var</span> d9   = [ <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>,-<span class="dv">1</span>,-<span class="dv">2</span>,-<span class="dv">3</span>,-<span class="dv">4</span>];
  <span class="kw">var</span> z5   = [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>];
  <span class="kw">var</span> i2   = <span class="ot">i9</span>.<span class="fu">slice</span>(<span class="dv">2</span>,-<span class="dv">2</span>);
  <span class="kw">var</span> d2   = <span class="ot">d9</span>.<span class="fu">slice</span>(<span class="dv">2</span>,-<span class="dv">2</span>);

  <span class="co">// 检查在 (r, c) 这一格，规则样式 (dr, dc) 是否被满足</span>
  <span class="co">// dr, dc 的组合可用来代表「垂直 | , 水平 - , 下斜 \ , 上斜 /」。</span>
  <span class="kw">var</span> patternCheck=<span class="kw">function</span>(board, turn, r, c, dr, dc) {
  <span class="kw">for</span> (<span class="kw">var</span> i = <span class="dv">0</span>; i &lt; <span class="ot">dr</span>.<span class="fu">length</span>; i++) {
  <span class="kw">var</span> tr = <span class="ot">Math</span>.<span class="fu">round</span>(r+dr[i]);
  <span class="kw">var</span> tc = <span class="ot">Math</span>.<span class="fu">round</span>(c+dc[i]);
  <span class="kw">if</span> (tr&lt;<span class="dv">0</span> ||tr &gt; <span class="dv">15</span> || tc&lt;<span class="dv">0</span> || tc&gt;<span class="dv">15</span>)
  <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> v = <span class="ot">board</span>.<span class="fu">m</span>[tr][tc];
  <span class="kw">if</span> (v != turn) <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
  }

  <span class="co">// 检查是否下 turn 这个子的人赢了。</span>
  <span class="kw">var</span> winCheck = <span class="kw">function</span>(board, turn) {
  <span class="kw">var</span> win = <span class="kw">false</span>;
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;<span class="dv">16</span>; r++) {
  <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;<span class="dv">16</span>; c++) {
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, z5, i2)) <span class="co">// 垂直 | ;</span>
  win = <span class="kw">true</span>;
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, z5)) <span class="co">// 水平 - ;</span>
  win = <span class="kw">true</span>;
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, i2)) <span class="co">// 下斜 \ ;</span>
  win = <span class="kw">true</span>;
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, i2, d2)) <span class="co">// 上斜 / ;</span>
  win = <span class="kw">true</span>;
  }
  }
  <span class="kw">if</span> (win) {
  <span class="fu">log</span>(<span class="st">&quot;%s 赢了！&quot;</span>, turn);  <span class="co">// 如果赢了就印出赢了</span>
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>); <span class="co">// 然后离开。</span>
  }
  <span class="kw">return</span> win;
  }

  <span class="kw">var</span> peopleTurn = <span class="kw">function</span>(board, turn, line) {
  <span class="kw">var</span> r = <span class="fu">parseInt</span>(line[<span class="dv">0</span>], <span class="dv">16</span>); <span class="co">// 取得下子的列 r (row)</span>
  <span class="kw">var</span> c = <span class="fu">parseInt</span>(line[<span class="dv">1</span>], <span class="dv">16</span>); <span class="co">// 取得下子的行 c (column)</span>
  <span class="kw">if</span> (r&lt;<span class="dv">0</span> || r&gt;<span class="dv">15</span> || c&lt;<span class="dv">0</span> || c&gt;<span class="dv">15</span>) <span class="co">// 检查是否超出范围</span>
  <span class="kw">throw</span> <span class="st">&quot;(row, col) 超出范围!&quot;</span>; <span class="co">// 若超出范围就丢出例外，下一轮重新输入。</span>
  <span class="kw">if</span> (<span class="ot">board</span>.<span class="fu">m</span>[r][c] != <span class="st">&#39;-&#39;</span>) <span class="co">// 检查该位置是否已被佔据</span>
  <span class="kw">throw</span> <span class="fu">format</span>(<span class="st">&quot;(%s%s) 已经被佔领了!&quot;</span>, line[<span class="dv">0</span>], line[<span class="dv">1</span>]); <span class="co">// 若被佔据就丢出例外，下一轮重新输入。</span>
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = turn; <span class="co">// 否则、将子下在使用者输入的 (r,c) 位置</span>
  }

  <span class="kw">var</span> P2P=<span class="kw">function</span>(b, turn, line) {
  <span class="fu">peopleTurn</span>(b, turn, line);
  <span class="ot">b</span>.<span class="fu">show</span>();         <span class="co">// 显示棋盘现况</span>
  <span class="fu">winCheck</span>(b, turn);
  <span class="kw">return</span> (turn == <span class="st">&#39;o&#39;</span>)?<span class="st">&#39;x&#39;</span>:<span class="st">&#39;o&#39;</span>; <span class="co">// 换对方下了。</span>
  }

  <span class="kw">var</span> attackScores = [ <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">10</span>, <span class="dv">30</span>, <span class="dv">100</span>, <span class="dv">500</span> ];
  <span class="kw">var</span> guardScores  = [ <span class="dv">0</span>, <span class="dv">2</span>,  <span class="dv">9</span>, <span class="dv">25</span>,  <span class="dv">90</span>, <span class="dv">400</span> ];
  <span class="kw">var</span> attack=<span class="dv">1</span>, guard=<span class="dv">2</span>;

  <span class="kw">var</span> getScore = <span class="kw">function</span>(board, r, c, turn, mode) {
  <span class="kw">var</span> score = <span class="dv">0</span>;
  <span class="kw">var</span> mScores = (mode === attack)?attackScores:guardScores;
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = turn;
  <span class="kw">for</span> (<span class="kw">var</span> start = <span class="dv">0</span>; start &lt;= <span class="dv">4</span>; start++) {
  <span class="kw">for</span> (<span class="kw">var</span> len = <span class="dv">5</span>; len &gt;= <span class="dv">1</span>; len--) {
  <span class="kw">var</span> end = start+len;
  <span class="kw">var</span> zero = <span class="ot">z9</span>.<span class="fu">slice</span>(start, start+len);
  <span class="kw">var</span> inc  = <span class="ot">i9</span>.<span class="fu">slice</span>(start, start+len);
  <span class="kw">var</span> dec  = <span class="ot">d9</span>.<span class="fu">slice</span>(start, start+len);
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, zero, inc)) <span class="co">// 攻击：垂直 | ;</span>
  score += mScores[len];
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, zero)) <span class="co">// 攻击：水平 - ;</span>
  score += mScores[len];
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, inc)) <span class="co">// 攻击：下斜 \ ;</span>
  score += mScores[len];
  <span class="kw">if</span> (<span class="fu">patternCheck</span>(board, turn, r, c, inc, dec)) <span class="co">// 攻击：上斜 / ;</span>
  score += mScores[len];
  }
  }
  <span class="ot">board</span>.<span class="fu">m</span>[r][c] = <span class="st">&#39;-&#39;</span>;
  <span class="kw">return</span> score;
  }

  <span class="kw">var</span> computerTurn = <span class="kw">function</span>(board, turn) {
  <span class="kw">var</span> best = { <span class="dt">r</span>:<span class="dv">0</span>, <span class="dt">c</span>:<span class="dv">0</span>, <span class="dt">score</span>:-<span class="dv">1</span> };
  <span class="kw">for</span> (<span class="kw">var</span> r=<span class="dv">0</span>; r&lt;=<span class="dv">15</span>; r++) {
  <span class="kw">for</span> (<span class="kw">var</span> c=<span class="dv">0</span>; c&lt;=<span class="dv">15</span>; c++) {
  <span class="kw">if</span> (<span class="ot">board</span>.<span class="fu">m</span>[r][c] !== <span class="st">&#39;-&#39;</span>)
  <span class="kw">continue</span>;
  <span class="kw">var</span> attackScore = <span class="fu">getScore</span>(board, r, c, <span class="st">&#39;x&#39;</span>, attack);  <span class="co">// 攻击分数</span>
  <span class="kw">var</span> guardScore  = <span class="fu">getScore</span>(board, r, c, <span class="st">&#39;o&#39;</span>, guard);   <span class="co">// 防守分数</span>
  <span class="kw">var</span> score = attackScore+guardScore;
  <span class="kw">if</span> (score &gt; <span class="ot">best</span>.<span class="fu">score</span>) {
  <span class="ot">best</span>.<span class="fu">r</span> = r;
  <span class="ot">best</span>.<span class="fu">c</span> = c;
  <span class="ot">best</span>.<span class="fu">score</span> = score;
  }
  }
  }
  <span class="fu">log</span>(<span class="st">&quot;best=%j&quot;</span>, best);
  <span class="ot">board</span>.<span class="fu">m</span>[<span class="ot">best</span>.<span class="fu">r</span>][<span class="ot">best</span>.<span class="fu">c</span>] = turn; <span class="co">// 否则、将子下在使用者输入的 (r,c) 位置</span>
  }

  <span class="kw">var</span> P2C=<span class="kw">function</span>(b, turn, line) {
  <span class="fu">peopleTurn</span>(b, <span class="st">&#39;o&#39;</span>, line);
  <span class="ot">b</span>.<span class="fu">show</span>();         <span class="co">// 显示棋盘现况</span>
  <span class="fu">winCheck</span>(b, <span class="st">&#39;o&#39;</span>); <span class="co">// 检查下了这子之后是否赢了！</span>
  <span class="fu">computerTurn</span>(b, <span class="st">&#39;x&#39;</span>, line);
  <span class="ot">b</span>.<span class="fu">show</span>();
  <span class="fu">winCheck</span>(b, <span class="st">&#39;x&#39;</span>);
  <span class="kw">return</span> <span class="st">&#39;o&#39;</span>;
  }

  <span class="kw">var</span> chess=<span class="kw">function</span>(doLine) {
  <span class="co">// 主程式开始</span>
  <span class="kw">var</span> b = <span class="kw">new</span> <span class="fu">Board</span>(); <span class="co">// 建立棋盘</span>
  <span class="ot">b</span>.<span class="fu">show</span>();            <span class="co">// 显示棋盘</span>
  <span class="kw">var</span> turn = <span class="st">&#39;o&#39;</span>;      <span class="co">// o 先下</span>
  <span class="fu">prompt</span>(turn);        <span class="co">// 提示要求下子讯息，并接受输入。</span>
  <span class="ot">r</span>.<span class="fu">on</span>(<span class="st">&#39;line&#39;</span>, <span class="kw">function</span>(line) { <span class="co">// 每当读到一个字串时。</span>
  <span class="kw">try</span> {
  turn = <span class="fu">doLine</span>(b, turn, line);
  } <span class="kw">catch</span> (err) { <span class="co">// 若有丢出例外</span>
  <span class="fu">log</span>(err); <span class="co">// 则印出错误讯息。</span>
  }
  <span class="fu">prompt</span>(turn); <span class="co">// 提示要求下子讯息，并接受输入。</span>
  }).<span class="fu">on</span>(<span class="st">&#39;close&#39;</span>, <span class="kw">function</span>() { <span class="co">// 输入结束了</span>
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>); <span class="co">// 程式结束。</span>
  });
  }

  <span class="kw">if</span> (<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>] === <span class="st">&quot;P2P&quot;</span>) <span class="co">// 人对人下</span>
  <span class="fu">chess</span>(P2P);
  <span class="kw">else</span> <span class="kw">if</span> (<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>] === <span class="st">&quot;P2C&quot;</span>) <span class="co">// 人对电脑下</span>
  <span class="fu">chess</span>(P2C);
  <span class="kw">else</span> { <span class="co">// 命令下错，提示讯息！</span>
  <span class="fu">log</span>(<span class="st">&quot;人对人下：node chess P2P</span><span class="ch">\n</span><span class="st">人对电脑：node chess P2C&quot;</span>);
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>);
  }</code></pre>
  <h3 id="执行结果-4"><a href="#执行结果-4">执行结果</a></h3>
  <p>以下是一场对局的过程片段，您可以看到最后是 x 赢了，也就是人类赢了。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\chess&gt;node chess P2C
  0 1 2 3 4 5 6 7 8 9 a b c d e f
  0 - - - - - - - - - - - - - - - - 0
  1 - - - - - - - - - - - - - - - - 1
  2 - - - - - - - - - - - - - - - - 2
  3 - - - - - - - - - - - - - - - - 3
  4 - - - - - - - - - - - - - - - - 4
  5 - - - - - - - - - - - - - - - - 5
  6 - - - - - - - - - - - - - - - - 6
  7 - - - - - - - - - - - - - - - - 7
  8 - - - - - - - - - - - - - - - - 8
  9 - - - - - - - - - - - - - - - - 9
  a - - - - - - - - - - - - - - - - a
  b - - - - - - - - - - - - - - - - b
  c - - - - - - - - - - - - - - - - c
  d - - - - - - - - - - - - - - - - d
  e - - - - - - - - - - - - - - - - e
  f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

  将 o 下在 : 66
  0 1 2 3 4 5 6 7 8 9 a b c d e f
  0 - - - - - - - - - - - - - - - - 0
  1 - - - - - - - - - - - - - - - - 1
  2 - - - - - - - - - - - - - - - - 2
  3 - - - - - - - - - - - - - - - - 3
  4 - - - - - - - - - - - - - - - - 4
  5 - - - - - - - - - - - - - - - - 5
  6 - - - - - - o - - - - - - - - - 6
  7 - - - - - - - - - - - - - - - - 7
  8 - - - - - - - - - - - - - - - - 8
  9 - - - - - - - - - - - - - - - - 9
  a - - - - - - - - - - - - - - - - a
  b - - - - - - - - - - - - - - - - b
  c - - - - - - - - - - - - - - - - c
  d - - - - - - - - - - - - - - - - d
  e - - - - - - - - - - - - - - - - e
  f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

  best={&quot;r&quot;:6,&quot;c&quot;:7,&quot;score&quot;:31}
  0 1 2 3 4 5 6 7 8 9 a b c d e f
  0 - - - - - - - - - - - - - - - - 0
  1 - - - - - - - - - - - - - - - - 1
  2 - - - - - - - - - - - - - - - - 2
  3 - - - - - - - - - - - - - - - - 3
  4 - - - - - - - - - - - - - - - - 4
  5 - - - - - - - - - - - - - - - - 5
  6 - - - - - - o x - - - - - - - - 6
  7 - - - - - - - - - - - - - - - - 7
  8 - - - - - - - - - - - - - - - - 8
  9 - - - - - - - - - - - - - - - - 9
  a - - - - - - - - - - - - - - - - a
  b - - - - - - - - - - - - - - - - b
  c - - - - - - - - - - - - - - - - c
  d - - - - - - - - - - - - - - - - d
  e - - - - - - - - - - - - - - - - e
  f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

  ...

  best={&quot;r&quot;:6,&quot;c&quot;:3,&quot;score&quot;:144}
  0 1 2 3 4 5 6 7 8 9 a b c d e f
  0 - - - - - - - - - - - - - - - - 0
  1 - - - - - - - - - - - - - - - - 1
  2 - - - - - - - - - - - - - - - - 2
  3 - - - - - - - - - - - - - - - - 3
  4 - - - - x - - - - - - - - - - - 4
  5 - - - - - o - - - - - - - - - - 5
  6 - - - x o o o x - - - - - - - - 6
  7 - - - - - - - o - - - - - - - - 7
  8 - - - - - - - - x - - - - - - - 8
  9 - - - - - - - - - x - - - - - - 9
  a - - - - - - - - - - - - - - - - a
  b - - - - - - - - - - - - - - - - b
  c - - - - - - - - - - - - - - - - c
  d - - - - - - - - - - - - - - - - d
  e - - - - - - - - - - - - - - - - e
  f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f
  ...

  0 1 2 3 4 5 6 7 8 9 a b c d e f
  0 - - - - - - - - - - - - - - - - 0
  1 - - - - - - - - - - - - - - - - 1
  2 - - - - - - - - - - - - - - - - 2
  3 - - - - - - - - - - - - - - - - 3
  4 - - - - x - - - - - - - - - - - 4
  5 - - o - - o - - - - - - - - - - 5
  6 - - o x o o o x - - - - - - - - 6
  7 - - - - x o o o - - - - - - - - 7
  8 - - - - - x - - x - - - - - - - 8
  9 - - - - - - x - - x - - - - - - 9
  a - - - - - - - x - - - - - - - - a
  b - - - - - - - - - - - - - - - - b
  c - - - - - - - - - - - - - - - - c
  d - - - - - - - - - - - - - - - - d
  e - - - - - - - - - - - - - - - - e
  f - - - - - - - - - - - - - - - - f
  0 1 2 3 4 5 6 7 8 9 a b c d e f

  x 赢了！</code></pre>
  <h3 id="参考文献-9"><a href="#参考文献-9">参考文献</a></h3>
  <ul>
    <li><a href="http://zh.wikipedia.org/zh-tw/%E4%BA%94%E5%AD%90%E6%A3%8B">维基百科：五子棋</a></li>
  </ul>
  <h2 id="电脑下棋的关键-min-max-对局搜寻与-alpha-beta-修剪算法"><a href="#电脑下棋的关键-min-max-对局搜寻与-alpha-beta-修剪算法">电脑下棋的关键： Min-Max 对局搜寻与 Alpha-Beta 修剪算法</a></h2>
  <h3 id="前言-5"><a href="#前言-5">前言</a></h3>
  <p>虽然我们在前文设计五子棋程式时单纯使用了盘面评估函数就已经设计出了「具备自动下棋能力的电脑程式」，但是这种设计方法是不够强大的。</p>
  <p>电脑下棋要够强大，通常必须採用「Min-Max 对局搜寻法」，如果能够搜寻得愈深，电脑的棋力通常就会越高。</p>
  <p>但是、对於电脑而言，每一层都有很多可能的下法，对手也可能会有很多的回应方式，这样一层一层下去会有组合爆炸的问题。</p>
  <p>举例而言，假如对上文中有 256 格的棋盘而言，第一子的下法有 256 种，第二子的下法就有 255 种，....</p>
  <p>因此若我们要进行 n 层的彻底搜寻，那在下第一步之前就必须探询 256<em>255</em>...*(256-n+1) 这麼多种可能性，当 n 超过 10 层时，几乎任何电脑都不可能在短短数秒内完成这样的搜寻。</p>
  <p>於是我们就必须减少蒐寻的可能性，这时我们可以採用著名的「 Alpha-Beta Cut」修剪法来减少蒐寻的空间大小。</p>
  <p>让我们先来瞭解一下何谓 「Min-Max 对局搜寻法」。</p>
  <h3 id="min-max-对局搜寻法"><a href="#min-max-对局搜寻法">Min-Max 对局搜寻法</a></h3>
  <p>在下棋的时候，如果要打败对手，必须考量让自己得分最多，且让对手得分最少，Min-Max 正是根据这样的想法而设计出来的。</p>
  <p>必须注意的是，当电脑要下一子之前，当然会下让自己得分最多的那一格，但是这很容易会落入对手的陷阱，因为得分最多的那一格很可能接下来失分更多。</p>
  <p>於是、一个合理的想法是将所有层次分为「敌我双方」两类，我方下的那层得分越多越好，而对方下的那层失分越少越好。</p>
  <p>而且、我们不能假设对方是个笨蛋，因此在每一层上，我们都必须认为「对方可能会下出让我们失分最多的一步」，而我们必须尽可能选择「最大失分最小化」的策略，这种想法就导出了「Min-Max 对局搜寻法」，以下是一个范例。</p>
  <div class="figure">
    <img src="../img/Minimax.jpg" alt="图、Min-Max 对局搜寻法的范例" /><p class="caption">图、Min-Max 对局搜寻法的范例</p>
  </div>
  <p>在上图中、由於第 0 层代表我方下，所以我们取在第一层失分少的步骤，而第 1 层代表敌方下，所以假设他们也会採取对他们最有利的下法 (也就是对我们最不利的、让我们失分多的) ，整张图的推论逻辑就在这种 Min-Max 的过程中完成了。</p>
  <p>必须补充说明的是，图中的 -∞ 与 +∞ 通常代表该节点为树叶节点，也就是整盘棋已经结束。换句话说、有人输了或赢了。</p>
  <p>演算法： Min-Max 对局搜寻</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">minimax</span>(node, depth, maximizingPlayer)
  <span class="kw">if</span> depth = <span class="dv">0</span> or node is a terminal node
  <span class="kw">return</span> the heuristic value of node
  <span class="kw">if</span> maximizingPlayer
  bestValue := -∞
  <span class="kw">for</span> each child of node
  val := <span class="fu">minimax</span>(child, depth - <span class="dv">1</span>, FALSE))
  bestValue := <span class="fu">max</span>(bestValue, val);
  <span class="kw">return</span> bestValue
  <span class="kw">else</span>
  bestValue := +∞
  <span class="kw">for</span> each child of node
  val := <span class="fu">minimax</span>(child, depth - <span class="dv">1</span>, TRUE))
  bestValue := <span class="fu">min</span>(bestValue, val);
  <span class="kw">return</span> bestValue

  (* Initial call <span class="kw">for</span> maximizing player *)
  <span class="fu">minimax</span>(origin, depth, TRUE)</code></pre>
  <h3 id="alpha-beta-修剪法"><a href="#alpha-beta-修剪法">Alpha-Beta 修剪法</a></h3>
  <p>您可以看到 Min-Max 对每个节点都进行递迴展开，这种展开的数量是很庞大的，因此即使电脑非常快也展开不了几层，所以我们必须透过「Alpha-Beta 修剪法」减少展开的数量，以下是一个范例。</p>
  <div class="figure">
    <img src="../img/AlphaBetaExample.jpg" alt="图、 Alpha-Beta 修剪法的范例" /><p class="caption">图、 Alpha-Beta 修剪法的范例</p>
  </div>
  <p>在上图中，请注意上面 Min 层的 5 节点，您可以看到当该节点最左边子树的分数 5 已经计算出来后，由於 5 比 8 还小，因此不管后面的节点分数为多少，都不可能让其父节点变得比 5 还要大，所以右边的子树都可以不用再计算了，这就是 Alpha-Beta 修剪法的原理。</p>
  <p>「Alpha-Beta 修剪法」其实是「Min-Max 对局搜寻法」的一个修改版，主要是在 Min-Max 当中加入了 α 与 β 两个纪录值，用来做为是否要修剪的参考标准，演算法如下所示。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">alphabeta</span>(node, depth, α, β, maximizingPlayer)
  <span class="kw">if</span> depth = <span class="dv">0</span> or node is a terminal node
  <span class="kw">return</span> the heuristic value of node
  <span class="kw">if</span> maximizingPlayer
  <span class="kw">for</span> each child of node
  α := <span class="fu">max</span>(α, <span class="fu">alphabeta</span>(child, depth - <span class="dv">1</span>, α, β, FALSE))
  <span class="kw">if</span> β ≤ α
  <span class="kw">break</span> (* β cut-off *)
  <span class="kw">return</span> α
  <span class="kw">else</span>
  <span class="kw">for</span> each child of node
  β := <span class="fu">min</span>(β, <span class="fu">alphabeta</span>(child, depth - <span class="dv">1</span>, α, β, TRUE))
  <span class="kw">if</span> β ≤ α
  <span class="kw">break</span> (* α cut-off *)
  <span class="kw">return</span> β

  (* Initial call <span class="kw">for</span> maximizing player *)
  <span class="fu">alphabeta</span>(origin, depth, -∞, +∞, TRUE)</code></pre>
  <h3 id="结语-8"><a href="#结语-8">结语</a></h3>
  <p>当然、 Alpha-Beta 修剪法并不保证能将对局树修剪得非常小，而且树的大小会与拜访的顺序有关，如果希望树可以比较小的话，应当从「对我方分数最高、对敌方分数最低」的节点开始处理，这样才能有效的降低整棵对局搜寻树的大小。</p>
  <h3 id="参考文献-10"><a href="#参考文献-10">参考文献</a></h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Minimax">Wikipedia:Minimax</a></li>
    <li><a href="http://en.wikipedia.org/wiki/Alpha-beta_pruning">Wikipedia:Alpha–beta pruning</a></li>
  </ul>
  <p>【本文由陈钟诚取材并修改自 <a href="http://zh.wikipedia.org">维基百科</a>，採用创作共用的 [姓名标示、相同方式分享] 授权】</p>
  <h1 id="逻辑推论与专家系统"><a href="#逻辑推论与专家系统">逻辑推论与专家系统</a></h1>
  <h2 id="布林逻辑"><a href="#布林逻辑">布林逻辑</a></h2>
  <p>在布林逻辑中，只有用来代表真假值的简单变数，像是 A, B, C, X, Y, Z .... 等，所以逻辑算式看来通常如下：</p>
  <ul>
    <li>P &amp; (P=&gt;Q) =&gt; Q.</li>
    <li>A &amp; B &amp; C =&gt; D | E.</li>
    <li>-(A &amp; B) &lt;=&gt; -A | -B.</li>
  </ul>
  <p>这种布林命题逻辑里没有函数的概念，只有简单的命题 (Proposition)，因此布林逻辑也称为命题逻辑 (Propositional Logic)。</p>
  <h2 id="谓词逻辑"><a href="#谓词逻辑">谓词逻辑</a></h2>
  <p>而在谓词逻辑里，则有「布林函数」的概念，因此其表达能力较强，例如以下是一些谓词逻辑的范例。</p>
  <ul>
    <li>Parent(x,y) &lt;= Father(x,y).</li>
    <li>Parent(John, Johnson).</li>
    <li>Ancestor(x,y) &lt;= Parent(x,y).</li>
    <li>Ancestor(x,y) &lt;= Ancestor(x,z) &amp; Parent(z,y).</li>
  </ul>
  <p>您可以看到在这种逻辑系统里，有「布林变数」的概念 (像是 x, y, z 等等)，也有函数的概念，像是 Parent(), Father(), Ancestor() 等等。</p>
  <h2 id="一阶逻辑"><a href="#一阶逻辑">一阶逻辑</a></h2>
  <p>在上述这种谓词逻辑系统中，如果我们加上 <img src="../timg/8b141f94d437.jpg" /> (对於所有) 或 <img src="../timg/297f1fa5c654.jpg" /> (存在) 这两个变数限定符号，而其中的谓词不可以是变项，而必须要是常项，这种逻辑就称为一阶逻辑。</p>
  <ul>
    <li><img src="../timg/514fcee4eee7.jpg" /> ; 人都是会死的。</li>
    <li><img src="../timg/622fa223aee6.jpg" /> ; 苏格拉底是人。</li>
    <li><img src="../timg/66f17dc26b90.jpg" /> ; 苏格拉底会死。</li>
  </ul>
  <p>当然、规则可以更复杂，像是以下这个范例，就说明了「存在一些人可以永远被欺骗」。</p>
  <ul>
    <li><img src="../timg/d37038cf1d92.jpg" title="fig:" /></li>
  </ul>
  <h2 id="二阶逻辑"><a href="#二阶逻辑">二阶逻辑</a></h2>
  <p>如果一阶逻辑中的谓词，放宽成可以是变项的话 (这些变项可以加上 <img src="../timg/8b141f94d437.jpg" /> 与 <img src="../timg/32ff223f4b92.jpg" /> 等符号的约束)，那就变成了二阶逻辑，以下是一些二阶逻辑的规则范例。</p>
  <ul>
    <li><img src="../timg/d12b91ab3a7b.jpg" /><br /></li>
    <li><img src="../timg/41d3eb0c5f8c.jpg" /></li>
    <li><img src="../timg/d01e95cc8ac8.jpg" /> ; 数学归纳法。</li>
  </ul>
  <h2 id="专家系统"><a href="#专家系统">专家系统</a></h2>
  <p>透过逻辑推论的方式，我们很容易就可以建构出一种「问题-回答」系统，这种系统会根据逻辑规则进行推论，让您透过对话的方式得到问题的答案，以下是一个「动物分类专家系统」的范例。</p>
  <p>动物世界规则库 : animal.kb</p>
<pre><code>哺乳类 &lt;= 有毛.
  哺乳类 &lt;= 泌乳.
  鸟类   &lt;= 有羽毛.
  鸟类   &lt;= 会飞 &amp; 生蛋.
  食肉类 &lt;= 哺乳类 &amp; 吃肉.
  食肉类 &lt;= 有爪 &amp; 利齿 &amp; 两眼前视.
  有蹄类 &lt;= 哺乳类 &amp; 有蹄.
  偶蹄类 &lt;= 哺乳类 &amp; 反芻.
  猎豹   &lt;= 哺乳类 &amp; 吃肉 &amp; 斑点.
  老虎   &lt;= 哺乳类 &amp; 吃肉 &amp; 条纹.
  长颈鹿 &lt;= 有蹄类 &amp; 长腿 &amp; 斑点.
  斑马   &lt;= 有蹄类 &amp; 条纹.
  鸵鸟   &lt;= 鸟类 &amp; 长腿.</code></pre>
  <p>此时如果您在对话中描述某些事实，例如以下的范例：</p>
<pre><code>问题：请问该动物有毛吗? (1. 有毛 2. 没毛)
  请选择 =&gt; 1

  问题：请问该动物吃肉吗? (1. 吃肉 2. 不吃肉)
  请选择 =&gt; 1

  问题：请问该动物有条纹或斑点吗? (1. 有条纹 2. 有斑点 3. 两者皆无)
  请选择 =&gt; 1

  回答：您所描述的动物应该是「老虎」。

  ## 推理引擎

  我们可以用程式撰写出「布林逻辑、谓词逻辑、一阶逻辑」等系统的推理引擎。

  推理引擎的设计方法大致可分为下列三类：

  1. 前向推论： 从「已知事实」开始不断的进行规则比对，推论出所有目前能推论出的「新事实」，然后将这些新事实加入「新知识库」中，直到推论出终端结果为止。

  举例而言、当我们在「动物规则库」的世界里，输入「有毛」时，则会推论出「哺乳类」这个结论。

  此时、如果再输入「吃肉」这个「新事实」，那麼由於「哺乳类」已经在「新知识库」中了，所以就会推论出「食肉类」。

  接著、如果我们再度输入「条纹」这个「新事实」，那麼推论系统就会推论出「老虎」这个结论。

  2. 后向推论：从问题开始，透过不断的反向连结，產生新的问题，一但某规则的所有问题都已经被满足，则可推出该规则的结论。

  举例而言、假如有一个「家族世界」的规则库如下。
</code></pre>
  <p>parent(x,y) &lt;= father(x,y). parent(x,y) &lt;= mother(x,y). ancestor(x,y) &lt;= parent(x,y). ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).</p>
  <p>father(John, Johnson). mother(Mary, Johnson). father(George, John). father(John, Jake). ```</p>
  <p>当我们输入 ancestor(p, Johnson) 时，则后向堆论引擎与 ancestor(x,z) 比对符合后会触发下列规则：</p>
  <pre><code>ancestor(x,y) &lt;= parent(x,y).</code></pre>
  <p>然后将 (x=p, y=Johnson) 绑定后，企图寻找前题 parent(x,Johnson).</p>
  <p>接著 parent(x,Johnson) 会再度触发下列规则：</p>
  <pre><code>parent(x,y)   &lt;= father(x,y).</code></pre>
  <p>於是再度寻找前题 father(x,Johnson)。</p>
  <p>然后 father(x,Johnson) 会比对到 father(John, Johnson) 这个事实，於是将 x 与 John 绑定，得到 father(x=John, Johnson) 的结果。</p>
  <p>接著进行回溯，得到 parent(x=John, y=Johnson)，再回溯规则 <code>ancestor(x,y) &lt;= parent(x,y)</code> 得到新事实 ancestor(John, Johnson)。</p>
  <p>同样的，系统也能透过类似的程序推论出 ancestor(Mary, Johnson) , ancestor(Mary, Johnson), ancestor(George, John) 等新事实。</p>
  <p>更进一步的，后向推论还可以透过下列规则得到更多更深的推论：</p>
  <pre><code>ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).</code></pre>
  <p>在上述新事实的基础上，系统可以进行下列尝试</p>
  <pre><code>ancestor(x=George,z=Johnson) &lt;= ancestor(x=George,y=John) &amp; parent(y=John,z=Johnson).</code></pre>
  <p>然后得到「祖父级」的推论结果，也就是 ancestor(George, Johnson)。</p>
  <ol start="3" style="list-style-type: decimal">
    <li>第三种推论方法是採用 refutation 的方式，这是由罗宾逊 (John Alan Robinson) 於 1965 年所提出来的，可以用在「布林逻辑、谓词逻辑、甚至是一阶逻辑」上，而且这种方法在理论上是可以推论出所有事实的，因此是一种具有「完备性」(Complete) 的推论方法。</li>
  </ol>
  <p>Refutation 推论法是一种反证法，任何一阶逻辑的算式 P 只要在系统 S 当中是真的，只要将 -P 加入该系统 S 中，就可以经由反证法导出矛盾。如果 P 在系统 S 当中不是真的，那麼将 P 加入 S 当中就无法导出矛盾。</p>
  <p>Refutation 反证法是依靠一个称为 resolution 的逻辑规则，该规则如下所示：</p>
  <div class="figure">
    <img src="../timg/21fa3adc303f.jpg" />
  </div>
  <p>假如我们将上述算式中的 <img src="../timg/b4ffcfd79743.jpg" /> 写为 A，将 <img src="../timg/9018c1f2e831.jpg" /> 写为 B，则上述算式可以改写如下：</p>
  <div class="figure">
    <img src="../timg/940130743f3d.jpg" />
  </div>
  <p>透过这样的方式，我们可以检验任何一个规则 P 是否为真，只要将 -P 加入系统中，看看最后是否会导出空集合 (代表矛盾) 就行了。</p>
  <p>如果 -P 加入后导出了矛盾，那就代表 P 是个真理，於是我们就可以将 P 加入「新的事实库」当中。</p>
  <p>可惜的是、Refutation 推论法非常耗费时间，而且不一定会停下来，有可能会造成当机的情况，因此採用 Refutation 推论法的引擎真的很少见，至少笔者还没有见过。</p>
  <p>有了以上的认知之后，我们就可以开始实作推理引擎了。</p>
  <p>接下来我们会用 JavaScript + node.js 来设计「逻辑推论引擎与专家系统」，用程式人的角度来看看上述理论的真正意义吧！</p>
  <p>我们首先会设计一个「布林逻辑推论引擎」，然后用这个引擎建构一个「动物世界的专家系统」。</p>
  <p>接著我们会扩充到「谓词逻辑」上，设计一个「谓词逻辑推论引擎」，然后再用这个引擎建构出一个「家族关係的专家系统」。</p>
  <h2 id="实作布林逻辑的推论引擎"><a href="#实作布林逻辑的推论引擎">实作：布林逻辑的推论引擎</a></h2>
  <h3 id="程式码推理引擎"><a href="#程式码推理引擎">程式码：推理引擎</a></h3>
<pre class="sourceCode javascript"><code class="sourceCode javascript">档案：<span class="ot">kb</span>.<span class="fu">js</span> (Knowledge Base 的简写)

  <span class="kw">var</span> log = <span class="ot">console</span>.<span class="fu">log</span>;

  <span class="kw">var</span> kb = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">rules</span> = [];
  <span class="kw">this</span>.<span class="fu">facts</span> = {};
  <span class="kw">this</span>.<span class="fu">dict</span>  = {};
  }

  <span class="kw">var</span> kbp = <span class="ot">kb</span>.<span class="fu">prototype</span>;

  <span class="ot">kbp</span>.<span class="fu">load</span> = <span class="kw">function</span>(code) {
  <span class="kw">var</span> lines = <span class="ot">code</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[</span><span class="fl">\.</span><span class="bn">]</span><span class="fl">+</span><span class="ot"> </span><span class="fl">?</span><span class="ot">/</span>);
  <span class="fu">log</span>(<span class="st">&quot;%j&quot;</span>, lines);
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> lines) {
  <span class="kw">if</span> (lines[i].<span class="fu">trim</span>().<span class="fu">length</span> &gt; <span class="dv">0</span>)
  <span class="kw">this</span>.<span class="fu">addRule</span>(lines[i]);
  }
  }

  <span class="ot">kbp</span>.<span class="fu">isFact</span>=<span class="kw">function</span>(term) {
  <span class="kw">if</span> (<span class="ot">term</span>.<span class="fu">length</span> == <span class="dv">0</span>)
  <span class="kw">return</span> <span class="kw">true</span>;
  <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">facts</span>[term];
  }

  <span class="ot">kbp</span>.<span class="fu">check</span> = <span class="kw">function</span>(rule) {
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="ot">rule</span>.<span class="fu">terms</span>) {
  <span class="kw">var</span> term = <span class="ot">rule</span>.<span class="fu">terms</span>[i].<span class="fu">trim</span>();
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">isFact</span>(term))
  <span class="kw">continue</span>;
  <span class="kw">else</span>
  <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
  }

  <span class="ot">kbp</span>.<span class="fu">addFact</span> = <span class="kw">function</span>(term) {
  <span class="kw">this</span>.<span class="fu">facts</span>[term] = <span class="kw">true</span>;
  <span class="fu">log</span>(<span class="st">&quot;addFact(%s)&quot;</span>, term);
  }

  <span class="ot">kbp</span>.<span class="fu">addRule</span> = <span class="kw">function</span>(line) {
  <span class="kw">var</span> m = <span class="ot">line</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^</span><span class="bn">&lt;=]</span><span class="fl">*)(</span><span class="ot">&lt;=</span><span class="fl">(</span><span class="ot">.</span><span class="fl">*))?$</span><span class="ot">/</span>);
  <span class="kw">var</span> head = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">var</span> terms= (m[<span class="dv">3</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">3</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/&amp;</span><span class="fl">+</span><span class="ot">/</span>);
  <span class="fu">log</span>(<span class="st">&quot;rule:head=%s terms=%j&quot;</span>, head, terms);
  <span class="kw">var</span> rule = { <span class="dt">head</span>:head, <span class="dt">terms</span>:terms, <span class="dt">satisfy</span>:<span class="kw">false</span> };
  <span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">push</span>(rule);
  <span class="kw">this</span>.<span class="fu">dict</span>[head] = { <span class="dt">headHits</span>: [rule], <span class="dt">bodyHits</span>:[] };
  }

  <span class="ot">kbp</span>.<span class="fu">forwardChaining</span> = <span class="kw">function</span>() {
  <span class="kw">do</span> {
  <span class="kw">var</span> anySatisfy = <span class="kw">false</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">rules</span>) {
  <span class="kw">var</span> rule = <span class="kw">this</span>.<span class="fu">rules</span>[i];
  <span class="kw">if</span> (!<span class="ot">rule</span>.<span class="fu">satisfy</span>) {
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">check</span>(rule)) {
  <span class="kw">this</span>.<span class="fu">addFact</span>(<span class="ot">rule</span>.<span class="fu">head</span>);
  <span class="ot">rule</span>.<span class="fu">satisfy</span> = <span class="kw">true</span>;
  anySatisfy = <span class="kw">true</span>;
  }
  }
  }
  } <span class="kw">while</span> (anySatisfy);
  <span class="fu">log</span>(<span class="st">&quot;facts=%j&quot;</span>, <span class="ot">Object</span>.<span class="fu">keys</span>(<span class="kw">this</span>.<span class="fu">facts</span>));
  }

  <span class="ot">kbp</span>.<span class="fu">trySatisfy</span> = <span class="kw">function</span>(goal) {
  <span class="fu">log</span>(<span class="st">&quot;trySatisfy(%s)&quot;</span>, goal);
  <span class="kw">var</span> word = <span class="kw">this</span>.<span class="fu">dict</span>[goal];
  <span class="kw">if</span> (word == <span class="kw">null</span>) <span class="kw">return</span> <span class="kw">false</span>;
  <span class="kw">var</span> headHits = <span class="ot">word</span>.<span class="fu">headHits</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> headHits) {
  <span class="kw">var</span> rule = headHits[i];
  <span class="kw">if</span> (<span class="ot">rule</span>.<span class="fu">satisfy</span>) {
  <span class="kw">this</span>.<span class="fu">addFact</span>(goal);
  <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span> {
  <span class="kw">var</span> isSatisfy = <span class="kw">true</span>;
  <span class="kw">for</span> (<span class="kw">var</span> ti <span class="kw">in</span> <span class="ot">rule</span>.<span class="fu">terms</span>) {
  <span class="kw">var</span> term = <span class="ot">rule</span>.<span class="fu">terms</span>[ti];
  <span class="kw">var</span> satisfy = <span class="kw">this</span>.<span class="fu">trySatisfy</span>(term);
  <span class="kw">if</span> (!satisfy) isSatisfy = <span class="kw">false</span>;
  }
  <span class="ot">rule</span>.<span class="fu">satisfy</span> = isSatisfy;
  <span class="kw">if</span> (isSatisfy) {
  <span class="kw">this</span>.<span class="fu">addFact</span>(goal);
  <span class="kw">return</span> <span class="kw">true</span>;
  }
  }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="ot">kbp</span>.<span class="fu">backwardChaining</span> = <span class="kw">function</span>(goal) {
  <span class="kw">this</span>.<span class="fu">trySatisfy</span>(goal);
  <span class="fu">log</span>(<span class="st">&quot;facts=%j&quot;</span>, <span class="ot">Object</span>.<span class="fu">keys</span>(<span class="kw">this</span>.<span class="fu">facts</span>));
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = kb;</code></pre>
  <h3 id="简易的测试程式"><a href="#简易的测试程式">简易的测试程式</a></h3>
  <p>档案：kbTest.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用档案物件</span>
  <span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

  <span class="kw">var</span> code = <span class="st">&quot;A&lt;=B. B&lt;=C&amp;D. C&lt;=E. D&lt;=F. E. F. Z&lt;=C&amp;D&amp;G.&quot;</span>;
  <span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
  <span class="ot">kb1</span>.<span class="fu">load</span>(code);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();
  <span class="co">// kb1.backwardChaining(&quot;A&quot;);</span>
  <span class="co">// kb1.backwardChaining(&quot;Z&quot;);</span></code></pre>
  <h3 id="执行结果-5"><a href="#执行结果-5">执行结果</a></h3>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbTest
  [&quot;A&lt;=B&quot;,&quot;B&lt;=C&amp;D&quot;,&quot;C&lt;=E&quot;,&quot;D&lt;=F&quot;,&quot;E&quot;,&quot;F&quot;,&quot;Z&lt;=C&amp;D&amp;G&quot;,&quot;&quot;]
  rule:head=A terms=[&quot;B&quot;]
  rule:head=B terms=[&quot;C&quot;,&quot;D&quot;]
  rule:head=C terms=[&quot;E&quot;]
  rule:head=D terms=[&quot;F&quot;]
  rule:head=E terms=&quot;&quot;
  rule:head=F terms=&quot;&quot;
  rule:head=Z terms=[&quot;C&quot;,&quot;D&quot;,&quot;G&quot;]
  addFact(E)
  addFact(F)
  addFact(C)
  addFact(D)
  addFact(B)
  addFact(A)
  facts=[&quot;E&quot;,&quot;F&quot;,&quot;C&quot;,&quot;D&quot;,&quot;B&quot;,&quot;A&quot;]</code></pre>
  <h3 id="结语-9"><a href="#结语-9">结语</a></h3>
  <p>以上我们用 JavaScript 实作了一个简易的布林逻辑推论引擎，採用洪氏逻辑的语法，以及前向推论 (forwardChaining) 的方式。(程式中也有附上后向推论的函数 backwardChaining，读者可自行测试)。</p>
  <h2 id="实作专家系统---前向推论程式"><a href="#实作专家系统---前向推论程式">实作：专家系统 - 前向推论程式</a></h2>
  <p>以下是一个代表鸵鸟的动物世界规则库。</p>
  <p>规则库：animal_ostrich.kb</p>
<pre><code>哺乳类 &lt;= 有毛.
  哺乳类 &lt;= 泌乳.
  鸟类   &lt;= 有羽毛.
  鸟类   &lt;= 会飞 &amp; 生蛋.
  食肉类 &lt;= 哺乳类 &amp; 吃肉.
  食肉类 &lt;= 有爪 &amp; 利齿 &amp; 两眼前视.
  有蹄类 &lt;= 哺乳类 &amp; 有蹄.
  偶蹄类 &lt;= 哺乳类 &amp; 反芻.
  猎豹   &lt;= 哺乳类 &amp; 吃肉 &amp; 斑点.
  老虎   &lt;= 哺乳类 &amp; 吃肉 &amp; 条纹.
  长颈鹿 &lt;= 有蹄类 &amp; 长腿 &amp; 斑点.
  斑马   &lt;= 有蹄类 &amp; 条纹.
  鸵鸟   &lt;= 鸟类 &amp; 长腿.

  会飞.
  生蛋.
  长腿. </code></pre>
  <p>接著我们採用前述的「布林逻辑推论引擎 kb.js」，透过读入规则档并进行推论的方式，设计出「前向推论」的程式。</p>
  <p>档案：kbReason.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用档案物件</span>
  <span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

  <span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
  <span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 读取档案</span>

  <span class="ot">kb1</span>.<span class="fu">load</span>(code);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();</code></pre>
  <p>以下是上述「隐含鸵鸟前提」的规则库经过「前向布林引擎」推论后得到的执行结果。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbReason animal_ostrich.kb
  [&quot;哺乳类 &lt;= 有毛&quot;,&quot;哺乳类 &lt;= 泌乳&quot;,&quot;鸟类   &lt;= 有羽毛&quot;,&quot;鸟类   &lt;= 会飞 &amp; 生蛋&quot;,&quot;
  食肉类 &lt;= 哺乳类 &amp; 吃肉&quot;,&quot;食肉类 &lt;= 有爪 &amp; 利齿 &amp; 两眼前视&quot;,&quot;有蹄类 &lt;= 哺乳类 &amp;
  有蹄&quot;,&quot;偶蹄类 &lt;= 哺乳类 &amp; 反芻&quot;,&quot;猎豹   &lt;= 哺乳类 &amp; 吃肉 &amp; 斑点&quot;,&quot;老虎   &lt;= 哺乳
  类 &amp; 吃肉 &amp; 条纹&quot;,&quot;长颈鹿 &lt;= 有蹄类 &amp; 长腿 &amp; 斑点&quot;,&quot;斑马   &lt;= 有蹄类 &amp; 条纹&quot;,&quot;鸵
  鸟   &lt;= 鸟类 &amp; 长腿&quot;,&quot;会飞&quot;,&quot;生蛋&quot;,&quot;长腿&quot;,&quot;&quot;]
  rule:head=哺乳类 terms=[&quot;有毛&quot;]
  rule:head=哺乳类 terms=[&quot;泌乳&quot;]
  rule:head=鸟类 terms=[&quot;有羽毛&quot;]
  rule:head=鸟类 terms=[&quot;会飞 &quot;,&quot; 生蛋&quot;]
  rule:head=食肉类 terms=[&quot;哺乳类 &quot;,&quot; 吃肉&quot;]
  rule:head=食肉类 terms=[&quot;有爪 &quot;,&quot; 利齿 &quot;,&quot; 两眼前视&quot;]
  rule:head=有蹄类 terms=[&quot;哺乳类 &quot;,&quot; 有蹄&quot;]
  rule:head=偶蹄类 terms=[&quot;哺乳类 &quot;,&quot; 反芻&quot;]
  rule:head=猎豹 terms=[&quot;哺乳类 &quot;,&quot; 吃肉 &quot;,&quot; 斑点&quot;]
  rule:head=老虎 terms=[&quot;哺乳类 &quot;,&quot; 吃肉 &quot;,&quot; 条纹&quot;]
  rule:head=长颈鹿 terms=[&quot;有蹄类 &quot;,&quot; 长腿 &quot;,&quot; 斑点&quot;]
  rule:head=斑马 terms=[&quot;有蹄类 &quot;,&quot; 条纹&quot;]
  rule:head=鸵鸟 terms=[&quot;鸟类 &quot;,&quot; 长腿&quot;]
  rule:head=会飞 terms=&quot;&quot;
  rule:head=生蛋 terms=&quot;&quot;
  rule:head=长腿 terms=&quot;&quot;
  addFact(会飞)
  addFact(生蛋)
  addFact(长腿)
  addFact(鸟类)
  addFact(鸵鸟)
  facts=[&quot;会飞&quot;,&quot;生蛋&quot;,&quot;长腿&quot;,&quot;鸟类&quot;,&quot;鸵鸟&quot;]</code></pre>
  <p>您可以看到上述系统利用「会飞. 生蛋. 长腿. 」等三个属性，推论出了「鸟类、鸵鸟」这两个结论。</p>
  <p>这个结果符合我们的预期，因此该程式的运作是正常的。</p>
  <h2 id="实作专家系统---互动推论程式"><a href="#实作专家系统---互动推论程式">实作：专家系统 - 互动推论程式</a></h2>
  <p>当然、我们不一定要像前述范例那样，将「隐含前提」直接写死在规则库当中。</p>
  <p>我们也可以透过互动的方式让使用者输入这些「隐含前提」，逐步的让「推理引擎」推论出结果，以下是这种互动式推论的一个执行范例。</p>
  <p>首先、我们只要将以下的动物世界推论规则放在 animal.kb 规则档中。</p>
<pre><code>哺乳类 &lt;= 有毛.
  哺乳类 &lt;= 泌乳.
  鸟类   &lt;= 有羽毛.
  鸟类   &lt;= 会飞 &amp; 生蛋.
  食肉类 &lt;= 哺乳类 &amp; 吃肉.
  食肉类 &lt;= 有爪 &amp; 利齿 &amp; 两眼前视.
  有蹄类 &lt;= 哺乳类 &amp; 有蹄.
  偶蹄类 &lt;= 哺乳类 &amp; 反芻.
  猎豹   &lt;= 哺乳类 &amp; 吃肉 &amp; 斑点.
  老虎   &lt;= 哺乳类 &amp; 吃肉 &amp; 条纹.
  长颈鹿 &lt;= 有蹄类 &amp; 长腿 &amp; 斑点.
  斑马   &lt;= 有蹄类 &amp; 条纹.
  鸵鸟   &lt;= 鸟类 &amp; 长腿.</code></pre>
  <p>接著撰写一个通用的推论程式 kbQuery.js，其原始码如下所示：</p>
  <p>档案：kbQuery.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用档案物件</span>
  <span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./kb&#39;</span>);

  <span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
  <span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 读取档案</span>
  <span class="ot">kb1</span>.<span class="fu">load</span>(code);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();

  <span class="kw">var</span> r = <span class="fu">require</span>(<span class="st">&#39;readline&#39;</span>).<span class="fu">createInterface</span>(<span class="ot">process</span>.<span class="fu">stdin</span>, <span class="ot">process</span>.<span class="fu">stdout</span>);
  <span class="ot">r</span>.<span class="fu">setPrompt</span>(<span class="st">&#39;?- &#39;</span>);
  <span class="ot">r</span>.<span class="fu">prompt</span>();

  <span class="ot">r</span>.<span class="fu">on</span>(<span class="st">&#39;line&#39;</span>, <span class="kw">function</span>(line) {
  <span class="kw">var</span> term = <span class="ot">line</span>.<span class="fu">trim</span>();
  <span class="ot">kb1</span>.<span class="fu">addFact</span>(term);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();
  <span class="ot">r</span>.<span class="fu">prompt</span>();
  }).<span class="fu">on</span>(<span class="st">&#39;close&#39;</span>, <span class="kw">function</span>() {
  <span class="ot">process</span>.<span class="fu">exit</span>(<span class="dv">0</span>);
  });</code></pre>
  <p>然后、我们就可以透过互动的方式，输入指定的前提，推理系统将会适时推论出我们想要查询的动物，以下是一个执行的过程范例。</p>
<pre><code>C:\Dropbox\Public\web\ai\code\KB&gt;node kbQuery animal.kb
  [&quot;哺乳类 &lt;= 有毛&quot;,&quot;哺乳类 &lt;= 泌乳&quot;,&quot;鸟类   &lt;= 有羽毛&quot;,&quot;鸟类   &lt;= 会飞 &amp; 生蛋&quot;,&quot;
  食肉类 &lt;= 哺乳类 &amp; 吃肉&quot;,&quot;食肉类 &lt;= 有爪 &amp; 利齿 &amp; 两眼前视&quot;,&quot;有蹄类 &lt;= 哺乳类 &amp;
  有蹄&quot;,&quot;偶蹄类 &lt;= 哺乳类 &amp; 反芻&quot;,&quot;猎豹   &lt;= 哺乳类 &amp; 吃肉 &amp; 斑点&quot;,&quot;老虎   &lt;= 哺乳
  类 &amp; 吃肉 &amp; 条纹&quot;,&quot;长颈鹿 &lt;= 有蹄类 &amp; 长腿 &amp; 斑点&quot;,&quot;斑马   &lt;= 有蹄类 &amp; 条纹&quot;,&quot;鸵
  鸟   &lt;= 鸟类 &amp; 长腿&quot;,&quot;&quot;]
  rule:head=哺乳类 terms=[&quot;有毛&quot;]
  rule:head=哺乳类 terms=[&quot;泌乳&quot;]
  rule:head=鸟类 terms=[&quot;有羽毛&quot;]
  rule:head=鸟类 terms=[&quot;会飞 &quot;,&quot; 生蛋&quot;]
  rule:head=食肉类 terms=[&quot;哺乳类 &quot;,&quot; 吃肉&quot;]
  rule:head=食肉类 terms=[&quot;有爪 &quot;,&quot; 利齿 &quot;,&quot; 两眼前视&quot;]
  rule:head=有蹄类 terms=[&quot;哺乳类 &quot;,&quot; 有蹄&quot;]
  rule:head=偶蹄类 terms=[&quot;哺乳类 &quot;,&quot; 反芻&quot;]
  rule:head=猎豹 terms=[&quot;哺乳类 &quot;,&quot; 吃肉 &quot;,&quot; 斑点&quot;]
  rule:head=老虎 terms=[&quot;哺乳类 &quot;,&quot; 吃肉 &quot;,&quot; 条纹&quot;]
  rule:head=长颈鹿 terms=[&quot;有蹄类 &quot;,&quot; 长腿 &quot;,&quot; 斑点&quot;]
  rule:head=斑马 terms=[&quot;有蹄类 &quot;,&quot; 条纹&quot;]
  rule:head=鸵鸟 terms=[&quot;鸟类 &quot;,&quot; 长腿&quot;]
  facts=[]
  ?- 有毛
  addFact(有毛)
  addFact(哺乳类)
  facts=[&quot;有毛&quot;,&quot;哺乳类&quot;]
  ?- 吃肉
  addFact(吃肉)
  addFact(食肉类)
  facts=[&quot;有毛&quot;,&quot;哺乳类&quot;,&quot;吃肉&quot;,&quot;食肉类&quot;]
  ?- 条纹
  addFact(条纹)
  addFact(老虎)
  facts=[&quot;有毛&quot;,&quot;哺乳类&quot;,&quot;吃肉&quot;,&quot;食肉类&quot;,&quot;条纹&quot;,&quot;老虎&quot;]
  ?-</code></pre>
  <p>您可以看到当我们输入了「有毛、吃肉、条纹」等三个属性之后，系统推论出了「老虎」这个结论，这正式动物世界专家系统所应该传回的结果，不是吗？</p>
  <h2 id="实作谓词逻辑的推论引擎"><a href="#实作谓词逻辑的推论引擎">实作：谓词逻辑的推论引擎</a></h2>
  <p>接著、让我们将上述的「布林推论引擎」扩充，成为一个可以包含「布林函数」的「谓词逻辑」推论引擎。</p>
  <h3 id="程式码谓词推理引擎"><a href="#程式码谓词推理引擎">程式码：谓词推理引擎</a></h3>
  <p>档案：pkb.js (Predicate Knowledge Base 的简写)</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ml = <span class="fu">require</span>(<span class="st">&quot;./myLib&quot;</span>);

  <span class="kw">var</span> Predicate = <span class="kw">function</span>() {}

  <span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(str) {
  <span class="kw">var</span> m = <span class="ot">str</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^\(</span><span class="bn">]</span><span class="fl">*)\((</span><span class="bn">[</span><span class="fl">^\)</span><span class="bn">]</span><span class="fl">*)\)$</span><span class="ot">/</span>);
  <span class="kw">this</span>.<span class="fu">name</span>   = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">this</span>.<span class="fu">params</span> = (m[<span class="dv">2</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">2</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[,]</span><span class="ot">/</span>);
  <span class="kw">return</span> <span class="kw">this</span>;
  }

  <span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">format</span>(<span class="st">&quot;%s%j&quot;</span>, <span class="kw">this</span>.<span class="fu">name</span>, <span class="kw">this</span>.<span class="fu">params</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\&quot;</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\[</span><span class="ot">/gi</span>, <span class="st">&quot;(&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="fl">\]</span><span class="ot">/gi</span>, <span class="st">&quot;)&quot;</span>);
  }

  <span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">unify</span> = <span class="kw">function</span>(fact) {
  <span class="kw">var</span> map = {};
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">name</span> != <span class="ot">fact</span>.<span class="fu">name</span> || <span class="kw">this</span>.<span class="ot">params</span>.<span class="fu">length</span> != <span class="ot">fact</span>.<span class="ot">params</span>.<span class="fu">length</span>)
  <span class="kw">return</span> <span class="kw">null</span>;
  <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt;<span class="kw">this</span>.<span class="ot">params</span>.<span class="fu">length</span>; i++) {
  <span class="kw">var</span> p  = <span class="kw">this</span>.<span class="fu">params</span>[i];
  <span class="kw">var</span> fp = <span class="ot">fact</span>.<span class="fu">params</span>[i];
  <span class="kw">if</span> (map[p] == <span class="kw">null</span>) { <span class="co">// 参数 p 没有 bind，所以就 bind 上去</span>
  <span class="kw">if</span> (<span class="ot">p</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^</span><span class="bn">[a-z]</span><span class="fl">+</span><span class="ot"> !</span><span class="bn">[]</span><span class="fl">(</span><span class="ot">../timg/b66e6870f9c0.jpg</span><span class="fl">)</span><span class="ot"> /</span>)!=<span class="kw">null</span>)
  map[p] = fp;
  } <span class="kw">else</span> { <span class="co">// 参数 p 已 bind，检查是否有冲突。</span>
  <span class="kw">if</span> (map[p] == fp)
  map[p] = fp; <span class="co">// 没冲突，加入。</span>
  <span class="kw">else</span>
  <span class="kw">return</span> <span class="kw">null</span>; <span class="co">// 有冲突，传回 null;</span>
  }
  }
  <span class="kw">return</span> map;
  }

  <span class="co">// 若每个变数都填入了，那麼就是满足了 (satisfy)</span>
  <span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">satisfy</span> = <span class="kw">function</span>(map) {
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">params</span>) {
  <span class="kw">var</span> p = <span class="kw">this</span>.<span class="fu">params</span>[i];
  <span class="kw">if</span> (map[p] == <span class="kw">null</span>)
  <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
  }

  <span class="ot">Predicate</span>.<span class="ot">prototype</span>.<span class="fu">mapping</span> = <span class="kw">function</span>(map) {
  <span class="kw">var</span> term = <span class="kw">new</span> <span class="fu">Predicate</span>();
  <span class="ot">term</span>.<span class="fu">name</span> = <span class="kw">this</span>.<span class="fu">name</span>;
  <span class="ot">term</span>.<span class="fu">params</span> = [];
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">params</span>) {
  <span class="kw">var</span> p = <span class="kw">this</span>.<span class="fu">params</span>[i];
  <span class="ot">term</span>.<span class="ot">params</span>.<span class="fu">push</span>(map[p]);
  }
  <span class="kw">return</span> term;
  }

  <span class="kw">var</span> Rule = <span class="kw">function</span>() {}

  <span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">clone</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> r=<span class="kw">new</span> <span class="fu">Rule</span>();
  <span class="ot">r</span>.<span class="fu">head</span> = <span class="kw">this</span>.<span class="fu">head</span>;
  <span class="ot">r</span>.<span class="fu">terms</span> = <span class="kw">this</span>.<span class="fu">terms</span>;
  <span class="ot">r</span>.<span class="fu">map</span> = <span class="kw">this</span>.<span class="fu">map</span>;
  <span class="kw">return</span> r;
  }

  <span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(line) {
  <span class="kw">var</span> m = <span class="ot">line</span>.<span class="fu">match</span>(<span class="ot">/</span><span class="fl">^(</span><span class="bn">[</span><span class="fl">^</span><span class="bn">&lt;=]</span><span class="fl">*)(</span><span class="ot">&lt;=</span><span class="fl">(</span><span class="bn">[</span><span class="fl">^\{</span><span class="bn"> ![]</span><span class="fl">(</span><span class="ot">../timg/0568953a55be.jpg</span><span class="fl">)</span><span class="ot"> /</span>);
  <span class="kw">var</span> head = (m[<span class="dv">1</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">1</span>].<span class="fu">trim</span>();
  <span class="kw">var</span> terms= (m[<span class="dv">3</span>]==<span class="kw">null</span>)?<span class="st">&quot;&quot;</span>:m[<span class="dv">3</span>].<span class="fu">trim</span>().<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[&amp;]</span><span class="fl">+</span><span class="ot">/</span>);
  <span class="kw">this</span>.<span class="fu">head</span> = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(head);
  <span class="kw">this</span>.<span class="fu">terms</span> = [];
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="ot">terms</span>.<span class="fu">length</span>; i++) {
  <span class="kw">this</span>.<span class="ot">terms</span>.<span class="fu">push</span>(<span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(terms[i]));
  }
  <span class="kw">this</span>.<span class="fu">map</span> = {};
  <span class="kw">return</span> <span class="kw">this</span>;
  }

  <span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">toString</span> = <span class="kw">function</span>() {
  <span class="kw">return</span> <span class="ot">ml</span>.<span class="fu">format</span>(<span class="st">&quot;%s&lt;=%s%j&quot;</span>, <span class="kw">this</span>.<span class="fu">head</span>, <span class="kw">this</span>.<span class="ot">terms</span>.<span class="fu">join</span>(<span class="st">&quot;&amp;&quot;</span>), <span class="kw">this</span>.<span class="fu">map</span>);
  }

  <span class="ot">Rule</span>.<span class="ot">prototype</span>.<span class="fu">resolve</span> = <span class="kw">function</span>(fact) {
  <span class="kw">var</span> rmap = <span class="kw">this</span>.<span class="fu">map</span>;
  <span class="co">//  ml.log(&quot;resolve:rule=%s, fact=%s&quot;, this, fact);</span>
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">terms</span>) {
  <span class="kw">var</span> term = <span class="kw">this</span>.<span class="fu">terms</span>[i];
  <span class="kw">var</span> tmap = <span class="ot">term</span>.<span class="fu">unify</span>(fact);
  <span class="kw">if</span> (tmap == <span class="kw">null</span>) <span class="kw">continue</span>;
  <span class="co">//    ml.log(&quot;unify:%s;%s=%j&quot;, term, fact, tmap);</span>
  <span class="kw">var</span> isConflict = <span class="kw">false</span>;
  <span class="kw">for</span> (<span class="kw">var</span> mi <span class="kw">in</span> tmap) {
  <span class="kw">if</span> (rmap[mi]!=<span class="kw">null</span> &amp;&amp; rmap[mi] != tmap[mi])
  isConflict = <span class="kw">true</span>;
  }
  <span class="kw">if</span> (!isConflict) {
  <span class="co">//      ml.log(&quot; return map=%j&quot;, tmap);</span>
  <span class="kw">return</span> tmap;
  }
  }
  <span class="kw">return</span> <span class="kw">null</span>;
  }

  <span class="kw">var</span> KB = <span class="kw">function</span>() {
  <span class="kw">this</span>.<span class="fu">rules</span> = [];
  <span class="kw">this</span>.<span class="fu">facts</span> = [];
  <span class="kw">this</span>.<span class="fu">ruleMap</span> = {};
  <span class="kw">this</span>.<span class="fu">factMap</span> = {};
  <span class="kw">this</span>.<span class="fu">resolveMap</span> = {};
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">load</span> = <span class="kw">function</span>(code) {
  code = <span class="ot">code</span>.<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\s</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>);
  <span class="kw">var</span> lines = <span class="ot">code</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">[</span><span class="fl">\.</span><span class="bn">]</span><span class="fl">+</span><span class="ot"> </span><span class="fl">?</span><span class="ot">/</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;%j&quot;</span>, lines);
  <span class="kw">for</span> (<span class="kw">var</span> i <span class="kw">in</span> lines) {
  <span class="kw">var</span> line = lines[i].<span class="fu">trim</span>();
  <span class="kw">if</span> (<span class="ot">line</span>.<span class="fu">length</span> == <span class="dv">0</span>) <span class="kw">continue</span>;
  <span class="kw">if</span> (<span class="ot">line</span>.<span class="fu">indexOf</span>(<span class="st">&quot;&lt;=&quot;</span>)&gt;=<span class="dv">0</span>) {
  <span class="kw">this</span>.<span class="fu">addRule</span>(<span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(line));
  } <span class="kw">else</span>
  <span class="kw">this</span>.<span class="fu">addFact</span>(<span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(line));
  }
  <span class="kw">this</span>.<span class="fu">dump</span>();
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">dump</span> = <span class="kw">function</span>() {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;=====facts========&quot;</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>));
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;========rules=======&quot;</span>);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">join</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>));
  <span class="co">// ml.log(&quot;========resolveMap=======\n&quot;);</span>
  <span class="co">// ml.log(Object.keys(this.resolveMap).join(&quot;|&quot;));</span>
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">addFact</span> = <span class="kw">function</span>(fact) {
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">factMap</span>[<span class="ot">fact</span>.<span class="fu">toString</span>()] == <span class="kw">null</span>) {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;addFact:%s&quot;</span>, fact);
  <span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">push</span>(fact);
  <span class="kw">this</span>.<span class="fu">factMap</span>[<span class="ot">fact</span>.<span class="fu">toString</span>()] = fact;
  <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span>
  <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">addRule</span> = <span class="kw">function</span>(rule) {
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">ruleMap</span>[<span class="ot">rule</span>.<span class="fu">toString</span>()] == <span class="kw">null</span>) {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;addRule:%s&quot;</span>, <span class="ot">rule</span>.<span class="fu">toString</span>());
  <span class="kw">this</span>.<span class="ot">rules</span>.<span class="fu">push</span>(rule);
  <span class="kw">this</span>.<span class="fu">ruleMap</span>[<span class="ot">rule</span>.<span class="fu">toString</span>()] = rule;
  <span class="kw">return</span> <span class="kw">true</span>;
  } <span class="kw">else</span>
  <span class="kw">return</span> <span class="kw">false</span>;
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">genNew</span> = <span class="kw">function</span>(rule, fact) {
  <span class="kw">var</span> fmap = <span class="ot">rule</span>.<span class="fu">resolve</span>(fact);
  <span class="kw">if</span> (fmap == <span class="kw">null</span>) <span class="kw">return</span> <span class="kw">null</span>;
  <span class="kw">var</span> rmap = <span class="ot">ml</span>.<span class="fu">merge</span>(<span class="ot">rule</span>.<span class="fu">map</span>, fmap);
  <span class="kw">if</span> (<span class="ot">rule</span>.<span class="ot">head</span>.<span class="fu">satisfy</span>(rmap)) {
  <span class="kw">var</span> newFact = <span class="ot">rule</span>.<span class="ot">head</span>.<span class="fu">mapping</span>(rmap);
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">addFact</span>(newFact))
  <span class="kw">return</span> newFact;
  } <span class="kw">else</span> {
  <span class="kw">if</span> (!<span class="ot">ml</span>.<span class="fu">isEmpty</span>(fmap)) {
  <span class="kw">var</span> newRule = <span class="ot">rule</span>.<span class="fu">clone</span>();
  <span class="ot">newRule</span>.<span class="fu">map</span>  = rmap
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">addRule</span>(newRule))
  <span class="kw">return</span> newRule;
  }
  }
  <span class="kw">return</span> <span class="kw">null</span>;
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">forwardChaining</span> = <span class="kw">function</span>() {
  <span class="kw">do</span> {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;======forwardChaining============&quot;</span>);
  <span class="kw">var</span> anyNew = <span class="kw">false</span>;
  <span class="kw">for</span> (<span class="kw">var</span> fi=<span class="dv">0</span>; fi &lt; <span class="kw">this</span>.<span class="ot">facts</span>.<span class="fu">length</span>; fi++) {
  <span class="kw">var</span> fact=<span class="kw">this</span>.<span class="fu">facts</span>[fi];
  <span class="kw">for</span> (<span class="kw">var</span> ri <span class="kw">in</span> <span class="kw">this</span>.<span class="fu">rules</span>) {
  <span class="kw">var</span> rule = <span class="kw">this</span>.<span class="fu">rules</span>[ri];
  <span class="kw">if</span> (<span class="kw">this</span>.<span class="fu">resolveMap</span>[fi+<span class="st">&quot;,&quot;</span>+ri] == <span class="kw">null</span>) {
  <span class="kw">var</span> newObj = <span class="kw">this</span>.<span class="fu">genNew</span>(rule, fact);
  <span class="kw">if</span> (newObj != <span class="kw">null</span>) {
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;  %s;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, rule, fact);
  anyNew = <span class="kw">true</span>;
  }
  }
  <span class="kw">else</span>
  <span class="kw">this</span>.<span class="fu">resolveMap</span>[fi+<span class="st">&quot;,&quot;</span>+ri]=<span class="kw">true</span>;
  }
  }
  } <span class="kw">while</span> (anyNew);
  <span class="kw">this</span>.<span class="fu">dump</span>();
  }

  <span class="ot">KB</span>.<span class="ot">prototype</span>.<span class="fu">test</span> = <span class="kw">function</span>() {
  <span class="kw">var</span> fxy = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;father(x,y)&quot;</span>);
  <span class="kw">var</span> fjj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;father(John,Johnson)&quot;</span>);
  <span class="kw">var</span> rp = <span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(<span class="st">&quot;parent(x,y)&lt;=father(x,y)&quot;</span>);
  <span class="kw">var</span> ra = <span class="kw">new</span> <span class="fu">Rule</span>().<span class="fu">load</span>(<span class="st">&quot;ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z)&quot;</span>);
  <span class="kw">var</span> pgj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;ancestor(George,John)&quot;</span>);
  <span class="kw">var</span> pjj = <span class="kw">new</span> <span class="fu">Predicate</span>().<span class="fu">load</span>(<span class="st">&quot;parent(John,Johnson)&quot;</span>);
  <span class="ot">ra</span>.<span class="fu">map</span> = <span class="ot">ra</span>.<span class="fu">resolve</span>(pgj);
  <span class="ot">ra</span>.<span class="fu">map</span> = <span class="ot">ml</span>.<span class="fu">merge</span>(<span class="ot">ra</span>.<span class="fu">map</span>, <span class="ot">ra</span>.<span class="fu">resolve</span>(pjj));
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot;ra=%s&quot;</span>, ra);
  <span class="ot">ml</span>.<span class="fu">log</span>(<span class="st">&quot; satisfy=%d&quot;</span>, <span class="ot">ra</span>.<span class="ot">head</span>.<span class="fu">satisfy</span>(<span class="ot">ra</span>.<span class="fu">map</span>));
  }

  <span class="ot">module</span>.<span class="fu">exports</span> = KB;</code></pre>
  <h3 id="前向推论主程式pkbreason.js"><a href="#前向推论主程式pkbreason.js">前向推论主程式：pkbReason.js</a></h3>
  <p>档案：pkbReason.js</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>); <span class="co">// 引用档案物件</span>
  <span class="kw">var</span> kb = <span class="fu">require</span>(<span class="st">&#39;./pkb&#39;</span>);

  <span class="kw">var</span> kb1 = <span class="kw">new</span> <span class="fu">kb</span>();
  <span class="kw">var</span> code = <span class="ot">fs</span>.<span class="fu">readFileSync</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>], <span class="st">&quot;utf8&quot;</span>).<span class="fu">replace</span>(<span class="ot">/</span><span class="bn">\n</span><span class="ot">/gi</span>, <span class="st">&quot;&quot;</span>); <span class="co">// 读取档案</span>
  <span class="ot">kb1</span>.<span class="fu">load</span>(code);
  <span class="ot">kb1</span>.<span class="fu">forwardChaining</span>();</code></pre>
  <h3 id="推论规则范例"><a href="#推论规则范例">推论规则范例</a></h3>
  <p>规则档：family.pkb</p>
<pre><code>parent(x,y)   &lt;= father(x,y).
  parent(x,y)   &lt;= mother(x,y).
  ancestor(x,y) &lt;= parent(x,y).
  ancestor(x,z) &lt;= ancestor(x,y) &amp; parent(y,z).

  father(John, Johnson).
  mother(Mary, Johnson).
  father(George, John).
  father(John, Jake).</code></pre>
  <h3 id="执行结果-6"><a href="#执行结果-6">执行结果</a></h3>
<pre><code>C:\Dropbox\Public\web\ai\code\PKB&gt;node pkbReason family.pkb
  [&quot;parent(x,y)&lt;=father(x,y)&quot;,&quot;parent(x,y)&lt;=mother(x,y)&quot;,&quot;ancestor(x,y)&lt;=parent(x,
  y)&quot;,&quot;ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z)&quot;,&quot;father(John,Johnson)&quot;,&quot;mother(Ma
  ry,Johnson)&quot;,&quot;father(George,John)&quot;,&quot;father(John,Jake)&quot;,&quot;&quot;]
  addRule:parent(x,y)&lt;=father(x,y){}
  addRule:parent(x,y)&lt;=mother(x,y){}
  addRule:ancestor(x,y)&lt;=parent(x,y){}
  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
  addFact:father(John,Johnson)
  addFact:mother(Mary,Johnson)
  addFact:father(George,John)
  addFact:father(John,Jake)
  =====facts========
  father(John,Johnson)
  mother(Mary,Johnson)
  father(George,John)
  father(John,Jake)
  ========rules=======
  parent(x,y)&lt;=father(x,y){}
  parent(x,y)&lt;=mother(x,y){}
  ancestor(x,y)&lt;=parent(x,y){}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
  ======forwardChaining============
  addFact:parent(John,Johnson)
  parent(x,y)&lt;=father(x,y){};father(John,Johnson)

  addFact:parent(Mary,Johnson)
  parent(x,y)&lt;=mother(x,y){};mother(Mary,Johnson)

  addFact:parent(George,John)
  parent(x,y)&lt;=father(x,y){};father(George,John)

  addFact:parent(John,Jake)
  parent(x,y)&lt;=father(x,y){};father(John,Jake)

  addFact:ancestor(John,Johnson)
  ancestor(x,y)&lt;=parent(x,y){};parent(John,Johnson)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(John,Johnson)

  addFact:ancestor(Mary,Johnson)
  ancestor(x,y)&lt;=parent(x,y){};parent(Mary,Johnson)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;Mary&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(Mary,Johnson)

  addFact:ancestor(George,John)
  ancestor(x,y)&lt;=parent(x,y){};parent(George,John)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;George&quot;,&quot;z&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(George,John)

  addFact:ancestor(John,Jake)
  ancestor(x,y)&lt;=parent(x,y){};parent(John,Jake)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};parent(John,Jake)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(John,Johnson)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;Mary&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(Mary,Johnson)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,John)

  addFact:ancestor(George,Johnson)
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;};ancestor(Ge
  orge,John)

  addFact:ancestor(George,Jake)
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;};ancestor(Georg
  e,John)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(John,Jake)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,Johnson)

  addRule:ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){};ancestor(George,Jake)

  ======forwardChaining============
  =====facts========
  father(John,Johnson)
  mother(Mary,Johnson)
  father(George,John)
  father(John,Jake)
  parent(John,Johnson)
  parent(Mary,Johnson)
  parent(George,John)
  parent(John,Jake)
  ancestor(John,Johnson)
  ancestor(Mary,Johnson)
  ancestor(George,John)
  ancestor(John,Jake)
  ancestor(George,Johnson)
  ancestor(George,Jake)
  ========rules=======
  parent(x,y)&lt;=father(x,y){}
  parent(x,y)&lt;=mother(x,y){}
  ancestor(x,y)&lt;=parent(x,y){}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;Mary&quot;,&quot;z&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;George&quot;,&quot;z&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;y&quot;:&quot;John&quot;,&quot;z&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;Mary&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;John&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;John&quot;,&quot;y&quot;:&quot;Jake&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Johnson&quot;}
  ancestor(x,z)&lt;=ancestor(x,y)&amp;parent(y,z){&quot;x&quot;:&quot;George&quot;,&quot;y&quot;:&quot;Jake&quot;}</code></pre>
  <h3 id="结语-10"><a href="#结语-10">结语</a></h3>
  <p>以上我们用 JavaScript 实作了一个简易的谓词逻辑推论引擎，採用洪氏逻辑的语法，以及前向推论 (forwardChaining) 的方式。</p>
  <h1 id="结语-11"><a href="#结语-11">结语</a></h1>
  <h2 id="ai-的梦想-1"><a href="#ai-的梦想-1">AI 的梦想</a></h2>
  <p>AI 的问题吸引了无数研究者投入，也让无数研究者感到失望、甚至害怕。因为，即使投入了整整一辈子，从少年研究到白髮，很可能都无法在研究上取得重要的进展。这可以说是人类科学技术的『终极问题』，如果资讯科学界有诺贝尔奖的话，那我想，大概要超过五千的以上的资讯诺贝尔奖，才能到达上述科幻小说的情节。甚至，其中有些技术，很可能永远不会实现。在 AI 领域，我们必须学会的第一件事，就是谦卑。</p>
  <p>这些梦想中的技术，有些值得我们投入一辈子去实现。但是，有些技术，实现后却可能会造成大灾难，这在科幻小说当中早已被想像过了。科幻界经典的艾西莫夫 (Isaac Asimov ) 机器人系列小说 ，就是典型的例子。当人类企图用机器人三大定律控制机器人时，仍然发生的灾难事件之科幻故事。另外，像是电影骇客任务 当中，更描述了机器人统治世界后，人类只能在机器人的喂养之下，成为类似植物人的悲惨状况。因此，科技的进步，尤其是像 AI 技术与生物科技的进步，到底是福是祸，仍然是个谜。</p>
  <p>这些议题有点扯远了，我们根本还没踏出第一步，就已经开始想像一万步之后的结果了。然而，这些技术的困难度，没有研究过的人还真是难以想像。让我们用 AI 的学术龙头 – MIT AI 实验室的发展作为一个范例，说明 AI 领域有多麼困难。</p>
  <p>在 AI 歷史早期的 1970年代，MIT AI 实验室就已经是 AI 大师匯集之处，像是第一代的 Marvin Minsky 与 John McCarthy 等 AI 大师，他们研究的主题著重在人类大脑与智慧上。</p>
  <p>接著，Patrick Winston发现，大脑的研究太过困难，转而研究机械人控制的领域。但这领域仍然太难，於是 Harold Abelson 乾脆改研究玩具的控制，发明了 LOGO 语言，然后开始研究机械昆虫，企图研究昆虫的行走智慧。 於是，人工智慧的研究从人脑开始，变成人的手脚之研究，最后变成昆虫手脚的研究。2003 年七月，MIT AI 实验室与 Laboratory for Computer Science 合併，成为一个具有 97 个教授、大约 800 个研究生的超级研究团队 CSAIL ，不知道是否因为感到 AI 领域太难或需要整合其他领域所进行的调整。</p>
  <p>当然，这并不表示 MIT AI 实验室越做越差，相反的，他们越来越强，吸引了无数的 AI 领域研究者进入该实验室。但是，这个领域实在太过困难，以至於学者在 1940 年代，认为 1990 年时应该可以理解自然语言，到了 1980 年代，预估时间点延后到 2030 年，到了 2009 年的今天，我个人认为可能还要 100 年的时间，才能发展出成熟的自然语言理解技术。</p>
  <h2 id="ai-的困境"><a href="#ai-的困境">AI 的困境</a></h2>
  <p>尽管人工智慧的学术界已经努力了五十年以上了，但是，距离 AI 的理想，模拟人类智慧行为的目标，仍然无比的遥远。甚至，完全看不到实现的可能性。甚至，我们连问题到底困难在哪哩，都还不是很清楚。其中，往往最难的一点，也是最少被AI研究所提及的一点，就是评量函数设计上的困难。</p>
  <h3 id="评量方法的困难"><a href="#评量方法的困难">评量方法的困难</a></h3>
  <p>AI 的研究往往著重在方法的设计上，很少提及评量上的问题，然而，评量问题的困难其实反而是最难的。有经验的 AI 研究者通常会发现，要研究一个问题之前，必须先想清楚，如何进行实验的评量。如果没有想清楚就贸然投入，那往往做到最后一无所获。因为，会卡在实验的评量上动弹不得，导致研究无法进行。</p>
  <p>评量问题在资讯科学的其他领域通常较为客观，像是演算法的复杂度与使用空间都可以很明确的评量。即使无法用这些指标的评量方式，实作或模拟的结果也可以用来评量方法的好坏。但是，对於人工智慧领域的问题而言，评量往往是最难的，因为，人工智慧的目的是在模拟人类的智慧与行为，而能够用来评量结果好坏的，往往只有人才有办法。但是，科学研究的目的，却又正是在排除人类评价的主观性。於是，一方面需要人类介入进行评量，另一方面又要排除主观性，使得评量问题困难重重。</p>
  <p>这种困难，使得许多人工智慧的研究，反而比较像社会科学，而不像自然科学。举例而言，自然语言理解就是一个相当难以评量的领域。假如你今天写了一个程式，企图『理解』自然语言。那麼，如何评量这个程式是否真的『理解』了进行实验的那些输入文章呢？</p>
  <p>或许你会认为，这个问题的原因是因为，自然语言理解是一个定义不明的问题。因为我们不知道甚麼叫作理解。那让我们再举一个例子，就拿英翻中的机器翻译问题而言，将英文文章，翻译成中文文章，这个问题应该够清楚了吧？输入是一个英文字串 (包含标点符号以及换行的文字串)，而输出则是一个中文字串。同时懂英文与中文的人应该很清楚这个问题。</p>
  <p>然而，假如你今天写了一个翻译程式，可以进行英翻中的工作，那麼，这个程式到底有多好呢？我们应该如何评量翻译结果的好坏呢？</p>
  <p>一个可能的解决办法是，请一万个同时通晓英文及中文的专家，同时对於随机抽取出的一千篇网路文章，对其英文原文与翻译后的中文进行全面的阅读，然后每个人给出一个分数，分数高就代表程式好，分数低就代表程式不好。</p>
  <p>如果我们暂时不争论这样的方法是否具有客观性，但是这样的方法，所耗费的成本将无比巨大，任何以一个企图进行此实验的人都必须超级有钱，而且冒著破產的危险，这种困难当然会妨碍研究的进展。</p>
  <p>更糟糕的是，如果又有人写了另一个英翻中程式，整个实验又得重头来过。而且，这一万个中英文专家又要被召集过来，以无比的耐心再次读完两千篇文章 (一千篇英文原文，一千篇中文译文)。然后，还要再次的以相当公正客观的态度，给出丝毫不差的评价。姑且不管客观评价是否能做得到，要能让这些人投入这麼多的心力，也只有大量的钞票才能办到。</p>
  <p>同样的，针对交谈系统，也就是 Alan Turing 所提出的 Turing Test，我们要如何评价一个程式的好坏呢？这仍然要靠大量的使用者介入，然后看看每个使用者是否能判断出交谈的对方到底是电脑还是程式，在以判断正确或错误的比率，作为程式好坏的标准，这同样有很大的困难。其中一个困难是，同样的交谈过程通常不会出现两次，而且人类会透过经验学习，因此，当这些人知道对方可能是程式，而且有了与电脑对谈的经验之后，就会发现一些电脑的盲点。举例而言，问他是男是女，父母是谁，甚至透过介面传一张字跡潦草的图片给他，问他上面写了甚麼。那麼，这个交谈程式就必须具备影像识别的能力才行。</p>
  <p>撇开自然语言领域的问题不谈，其他领域呢？假如我们今天想设计一个语音辨识软体，就必须有一个标准的语音库，然后透过人的听觉，先将听到的声音打成文字档。然后，再利用程式进行语音辨识，看看与这些标准答案是否相同，才能决定程式的正确率。这个问题的评量相对简单一点，但仍有客观性的问题。</p>
  <p>首先，语音库到底应该用谁的声音，如果单用一个人的声音，那麼，是否会有所偏差。如果要用各种不同口音，各种不同年龄层，不同性别的人的声音，那建构语音库的工作仍然相当庞大。建立标准答案的工作也将相当吃力。</p>
  <p>对於像语音辨识与影像识别这些领域而言，虽然评量的问题通常较没有争议，但是测试资料与标准答案的问题，仍然相当困扰人。在这些研究的背后，研究者通常迫於无奈，必须出钱购买这些语音库、影像库与标准答案。而这些语音库与影像库，通常被许多商业机关，视为重要财產，要取得时还要签定智慧產权合约，以避免外流。</p>
  <p>正因为如此，这些领域往往没有共同的比较基准，这使得方法之间相当难以进行科学性的比较。当然，也就很难判断方法间的好坏，这将严重阻碍 AI技术的进步。</p>
  <p>还好，网际网路的出现，以及开放原始码风潮的盛行，缺乏标准测试资料的问题，开始有了的可能性。但是，我们还没看到大量的标准语音语料库与影像库出现，我们希望，透过类似开放原始码与维基百科的模式，具有这些资源之版权的个人或研究机构，能将这些重要的资料在网路上释出并且集中，成为人类公共资產的一部分，以帮助 AI 学术研究的进行，促进人类文明的进一步发展。</p>
  <p>另外，还有一些 AI 领域，连评量的可能性都很渺茫，举例而言，曾经有人做过利用 AI 技术自动画图，自动作曲的，那这些画出来的图，作出来的曲到底好不好，有多好呢？这已经不是工程浩大的问题了，而是艺术心理学上的问题。如果，有程式可以作出贝多芬、莫札特等级的曲子，那要给几分呢？</p>
  <p>关於艺术的例子或许太极端了，然而，许多设计上的问题都遭遇到同样的困难，像是一个电脑游戏到底设计得好不好，一个程式的品质到底如何等等？都已经不是可以客观评量的问题。虽然，这些不见得都是 AI 问题，但是却是资讯工程上重要的问题。然而，这些问题却无法被归类到学术问题当中。於是，学术界只好视若无睹，当作这些问题不存在。</p>
  <h3 id="布林逻辑的困境"><a href="#布林逻辑的困境">布林逻辑的困境</a></h3>
  <p>然而，现实世界的知识，往往不是绝对性的知识，我们很难说任何一件事情是 100% 正确的。然而，布林逻辑却要求要知识要 100% 正确，才能保证后续的推论无误。建构在稳固基础上的知识，固然较为稳固，但是，我们的知识往往像沙堆一样，没有 100% 的保障，这使得布林逻辑的应用，经常侷限在所谓的玩具问题 (Toy Problem) 上，而难以进入现实生活当中。</p>
  <p>布林逻辑的困难在影像识别上表现得特别明显。举例而言，电脑当中储存了许多影像图片，这些点都以二进位的 0 与 1 的形式储存在图片档中。按理讲，我们应该可以根据布林逻辑规则，推论出影像中的人物到底是『玛莉莲梦露』还是『李察吉尔』。然而，没有人能够写出这样的规则，二进位码与图像辨识之间，存在巨大的鸿沟，使得电脑见树不见林，只看到一堆点，却没有看到整张图。</p>
  <h3 id="类神经网路的困境"><a href="#类神经网路的困境">类神经网路的困境</a></h3>
  <p>类神经网路与布林逻辑恰好相反，当类神经网路看了一张图，然后告诉所那张图是玛莉莲梦露的照片时，程式设计人员会给予掌声，但是却不知道为何程式会告诉他这个答案。</p>
  <p>为何如此呢？程式设计人员用了类似反传递演算法设计出程式后，就会针对所想要的答案，对此类神经程式进行训练。举例而言，如果我们想要让电脑认识玛莉莲梦露，就可以用一大堆玛莉莲梦露的图档输入，作为正确答案，然后输入一大堆不是玛莉莲梦露的图档，作为负面教材。此时，程式对正面教材的预设答案是 1，而对负面教材的预设答案是 0。於是，类神经的训练开始啟动，训练完毕后，如果很幸运的，正确率达到百分之百。那麼，恭喜你，但是先别高兴！因为，如果你想知道为何程式这麼好，那答案是，不知道！这个结果只是一堆权重加权后经过非线性函数的结果。程式自己本身没有办法告诉你为何会这麼好，程式设计人员也无法知道，除非他读得懂这些权重的意义。(问题是，只要是人，通常就读不懂权重的意义)。</p>
  <h2 id="未来展望"><a href="#未来展望">未来展望</a></h2>
  <p>截至目前为止，本书讨论了「爬山演算法、神经网路、图形搜寻、电脑下棋、逻辑推论与专家系统」等主题。</p>
  <p>当然、我们还遗漏掉一些重要的主题，像是「模糊逻辑、机率统计、机器学习、资料挖矿、模式识别」等等，未来笔者将会对这些主题进行补充，</p>
</div>
<div id="footer">
  <a href="http://ccckmit.wikidot.com">陈钟诚</a>衍生自<a href="http://zh.wikipedia.org/">维基百科</a>之作品：採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">创作共用：姓名标示、相同方式分享</a> 的 <a href="license.html">授权方式</a>。
</div>
</body>
</html>
